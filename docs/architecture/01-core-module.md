# Core 模块详细实现原理

> 文档生成日期：2026-01-06
> 基于源码版本：当前 main 分支

## 1. 模块概述

`secs::core` 是整个 secs_lib 的基础设施层，提供跨模块复用的基础类型和工具：

- **基础类型**：`byte`、`bytes_view`、`mutable_bytes_view`
- **缓冲区管理**：`FixedBuffer`（预分配 + 可扩容）
- **错误处理**：`errc` 枚举与 `std::error_code` 集成
- **同步原语**：`Event`（协程可等待事件）

```
┌─────────────────────────────────────────────────────────────────────┐
│                         secs::core 模块                             │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌────────────┐ │
│  │   common    │  │   buffer    │  │    error    │  │   event    │ │
│  │  (types)    │  │ FixedBuffer │  │    errc     │  │   Event    │ │
│  └─────────────┘  └─────────────┘  └─────────────┘  └────────────┘ │
│                                                                     │
│  提供：byte/span、读写缓冲区、统一错误码、协程同步原语              │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 2. 基础类型（common.hpp）

### 2.1 类型定义

```cpp
namespace secs::core {
    using byte = std::uint8_t;           // 单字节
    using bytes_view = std::span<const byte>;      // 只读字节视图
    using mutable_bytes_view = std::span<byte>;    // 可写字节视图
}
```

### 2.2 常量配置

```
┌────────────────────────────────────────────────────────────────┐
│                    FixedBuffer 容量配置                         │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  kDefaultFixedBufferCapacity = 8KB                             │
│  ├── 小包场景：直接使用栈上 inline 数组                         │
│  └── 避免频繁堆分配                                             │
│                                                                │
│  kDefaultFixedBufferMaxCapacity = 64MB                         │
│  ├── 防止恶意输入导致无限扩容                                   │
│  └── 可通过构造函数参数自定义                                   │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 3. FixedBuffer 缓冲区

### 3.1 设计目标

```
┌────────────────────────────────────────────────────────────────────┐
│                    FixedBuffer 设计目标                             │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│  1. 小包优先走 inline 预分配（默认 8KB 栈数组）                     │
│     └── 减少热路径上的堆分配                                        │
│                                                                    │
│  2. 支持 compact（搬移可读区到头部）                                │
│     └── 回收前缀空洞，减少扩容次数                                  │
│                                                                    │
│  3. 必要时 grow（扩容到 heap）                                      │
│     └── 2 倍增长策略，受 max_capacity 上限约束                      │
│                                                                    │
│  4. 无线程安全保证                                                  │
│     └── 调用方需自行保证并发安全                                    │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

### 3.2 内存布局

```
┌────────────────────────────────────────────────────────────────────┐
│                    FixedBuffer 内存布局                             │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│  小包场景（capacity <= 8KB）：使用 inline_ 栈数组                   │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ inline_[8192]                                               │   │
│  │ ┌─────────┬───────────────────────┬─────────────────────┐   │   │
│  │ │ consumed│    readable data      │    writable space   │   │   │
│  │ │ (空洞)  │                       │                     │   │   │
│  │ └─────────┴───────────────────────┴─────────────────────┘   │   │
│  │      ^                ^                              ^      │   │
│  │      0           read_pos_                     write_pos_   │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                    │
│  大包场景（capacity > 8KB）：使用 heap_ 动态数组                    │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ heap_[capacity_]                                            │   │
│  │ ┌─────────┬───────────────────────┬─────────────────────┐   │   │
│  │ │ consumed│    readable data      │    writable space   │   │   │
│  │ │ (空洞)  │                       │                     │   │   │
│  │ └─────────┴───────────────────────┴─────────────────────┘   │   │
│  │      ^                ^                              ^      │   │
│  │      0           read_pos_                     write_pos_   │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

### 3.3 关键操作流程

#### append() 追加数据

```
┌─────────────────────────────────────────────────────────────────┐
│                      append(data) 流程                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. ensure_writable(data.size())                                │
│     │                                                           │
│     ├─────> 尾部空间足够？                                       │
│     │       └── YES: 直接返回                                    │
│     │       └── NO:  继续                                        │
│     │                                                           │
│     ├─────> compact() 回收前缀空洞                               │
│     │       ┌─────────────────────────────────────────┐         │
│     │       │ Before: [consumed][data      ][space]   │         │
│     │       │ After:  [data      ][    space        ] │         │
│     │       └─────────────────────────────────────────┘         │
│     │       └── 空间足够？YES: 返回                              │
│     │                                                           │
│     └─────> grow(required) 扩容                                  │
│             ├── 计算新容量（2 倍增长，不超过 max_capacity）       │
│             ├── 分配新 heap_                                     │
│             ├── 复制已有数据到新缓冲区头部                        │
│             └── 更新 read_pos_=0, write_pos_=readable             │
│                                                                 │
│  2. memcpy(data_mutable() + write_pos_, data, size)             │
│                                                                 │
│  3. write_pos_ += data.size()                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### consume() 消费数据

```
┌─────────────────────────────────────────────────────────────────┐
│                      consume(n) 流程                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Before:                                                        │
│  ┌─────────┬─────────────────────────────┬─────────────────┐    │
│  │ consumed│         readable             │    writable     │    │
│  │  (n=0)  │                             │                 │    │
│  └─────────┴─────────────────────────────┴─────────────────┘    │
│       ^              ^                            ^              │
│       0          read_pos_                   write_pos_          │
│                                                                 │
│  After consume(5):                                              │
│  ┌──────────────────┬────────────────────┬─────────────────┐    │
│  │   consumed (5)   │      readable      │    writable     │    │
│  │    (空洞)         │                    │                 │    │
│  └──────────────────┴────────────────────┴─────────────────┘    │
│          ^                   ^                    ^              │
│          0              read_pos_+5          write_pos_          │
│                                                                 │
│  特殊情况：read_pos_ == write_pos_ 时自动 clear()               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3.4 核心方法汇总

| 方法 | 功能 | 复杂度 |
|------|------|--------|
| `capacity()` | 返回当前容量 | O(1) |
| `size()` | 返回可读字节数 | O(1) |
| `readable_bytes()` | 获取可读区视图 | O(1) |
| `writable_bytes()` | 获取可写区视图 | O(1) |
| `append(data)` | 追加数据 | O(n) / O(n+m) 扩容 |
| `commit(n)` | 确认写入 n 字节 | O(1) |
| `consume(n)` | 消费 n 字节 | O(1) |
| `compact()` | 压缩空洞 | O(n) |
| `clear()` | 清空缓冲区 | O(1) |
| `reserve(cap)` | 预留容量 | O(n) |

---

## 4. 错误码系统（error.hpp/cpp）

### 4.1 错误码枚举

```cpp
enum class errc : int {
    ok = 0,              // 成功
    timeout = 1,         // 等待超时
    cancelled = 2,       // 被主动取消
    buffer_overflow = 3, // 缓冲区溢出
    invalid_argument = 4,// 非法参数
    out_of_memory = 5,   // 内存分配失败
};
```

### 4.2 与 std::error_code 集成

```
┌─────────────────────────────────────────────────────────────────┐
│               std::error_code 集成机制                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 定义 secs_error_category（继承 std::error_category）        │
│     ├── name() -> "secs.core"                                   │
│     └── message(int) -> 错误描述字符串                          │
│                                                                 │
│  2. 特化 std::is_error_code_enum<secs::core::errc>              │
│     └── 允许 errc 隐式转换为 std::error_code                    │
│                                                                 │
│  3. 提供 make_error_code(errc e)                                │
│     └── 返回 {int(e), secs.core category}                       │
│                                                                 │
│  使用示例：                                                     │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │ std::error_code ec = secs::core::errc::timeout;           │  │
│  │ if (ec) {                                                 │  │
│  │     // ec.category().name() == "secs.core"                │  │
│  │     // ec.message() == "timeout"                          │  │
│  │ }                                                         │  │
│  └───────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 5. Event 协程同步原语

### 5.1 设计语义

```
┌─────────────────────────────────────────────────────────────────┐
│                      Event 语义说明                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Event 是一个"协程可等待事件"，类似于 Win32 Event 或             │
│  pthread_cond，但专为 Asio 协程设计。                            │
│                                                                 │
│  状态：                                                         │
│  ┌────────────────┐     set()      ┌────────────────┐           │
│  │   未置位        │ ───────────> │   已置位        │           │
│  │  (signaled_    │               │  (signaled_    │           │
│  │   = false)     │ <─────────── │   = true)      │           │
│  └────────────────┘    reset()    └────────────────┘           │
│                                                                 │
│  操作：                                                         │
│  ├── set()    : 置位，唤醒所有等待者，后续 wait 立即返回         │
│  ├── reset()  : 清除置位状态，后续 wait 会阻塞                   │
│  ├── cancel() : 取消所有等待者（返回 cancelled），不置位         │
│  └── async_wait(timeout): 协程等待直到 set/cancel/timeout       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.2 内部实现机制

```
┌─────────────────────────────────────────────────────────────────┐
│                    Event 实现原理                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  核心数据结构：                                                  │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │  bool signaled_;                    // 当前置位状态        │  │
│  │  uint64_t set_generation_;          // set() 调用计数      │  │
│  │  uint64_t cancel_generation_;       // cancel() 调用计数   │  │
│  │  list<shared_ptr<steady_timer>> waiters_;  // 等待者列表   │  │
│  └───────────────────────────────────────────────────────────┘  │
│                                                                 │
│  async_wait() 流程：                                            │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │  1. 若 signaled_ == true, 立即返回 ok                      │  │
│  │  2. 记录当前 set_generation_ 和 cancel_generation_         │  │
│  │  3. 创建 steady_timer, 设置超时                            │  │
│  │  4. 加入 waiters_ 列表                                     │  │
│  │  5. co_await timer.async_wait()                           │  │
│  │  6. 从 waiters_ 移除                                       │  │
│  │  7. 判断唤醒原因：                                         │  │
│  │     ├── set_generation_ 变化 -> 返回 ok                    │  │
│  │     ├── cancel_generation_ 变化 -> 返回 cancelled          │  │
│  │     ├── timer 正常到期 -> 返回 timeout                     │  │
│  │     └── 其他错误 -> 返回原始 error_code                    │  │
│  └───────────────────────────────────────────────────────────┘  │
│                                                                 │
│  set()/cancel() 如何唤醒等待者：                                 │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │  for (auto& timer : waiters_) {                           │  │
│  │      timer->cancel();  // 触发 async_wait 返回            │  │
│  │  }                                                        │  │
│  │  // 等待者通过 generation 计数判断是 set 还是 cancel       │  │
│  └───────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.3 使用场景

```
┌─────────────────────────────────────────────────────────────────┐
│                    Event 典型使用场景                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  场景 1：等待连接建立                                            │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │  Event connected_;                                        │  │
│  │                                                           │  │
│  │  // 连接协程                                              │  │
│  │  co_await async_connect();                                │  │
│  │  connected_.set();  // 通知等待者                         │  │
│  │                                                           │  │
│  │  // 业务协程                                              │  │
│  │  auto ec = co_await connected_.async_wait(timeout);       │  │
│  │  if (!ec) { /* 连接成功 */ }                              │  │
│  └───────────────────────────────────────────────────────────┘  │
│                                                                 │
│  场景 2：请求-响应匹配                                           │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │  struct Pending {                                         │  │
│  │      Event ready;                                         │  │
│  │      Message response;                                    │  │
│  │  };                                                       │  │
│  │                                                           │  │
│  │  // 发送请求并等待                                        │  │
│  │  auto pending = make_shared<Pending>();                   │  │
│  │  pending_[system_bytes] = pending;                        │  │
│  │  co_await send(request);                                  │  │
│  │  co_await pending->ready.async_wait(t3);                  │  │
│  │  return pending->response;                                │  │
│  │                                                           │  │
│  │  // 接收循环                                              │  │
│  │  auto msg = co_await receive();                           │  │
│  │  if (auto it = pending_.find(msg.system_bytes)) {         │  │
│  │      it->second->response = msg;                          │  │
│  │      it->second->ready.set();                             │  │
│  │  }                                                        │  │
│  └───────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 6. 模块依赖关系

```
┌─────────────────────────────────────────────────────────────────┐
│                    core 模块依赖关系                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  外部依赖：                                                     │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  asio (standalone)                                       │   │
│  │  ├── asio::steady_timer      (Event 实现)                │   │
│  │  ├── asio::awaitable         (协程支持)                  │   │
│  │  ├── asio::any_io_executor   (执行器抽象)                │   │
│  │  └── asio::use_awaitable     (协程 token)                │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  标准库依赖：                                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  <span>           (bytes_view)                          │   │
│  │  <system_error>   (error_code/error_category)           │   │
│  │  <memory>         (unique_ptr)                          │   │
│  │  <cstring>        (memcpy/memmove)                      │   │
│  │  <chrono>         (steady_clock/duration)               │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  被依赖情况：                                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  secs::ii       -> core::byte, core::bytes_view         │   │
│  │  secs::hsms     -> core::byte, core::Event, core::errc  │   │
│  │  secs::secs1    -> core::byte, core::errc               │   │
│  │  secs::protocol -> core::Event, core::errc              │   │
│  │  secs::sml      -> core::errc                           │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 7. 源文件清单

| 文件 | 行数 | 说明 |
|------|------|------|
| `include/secs/core/common.hpp` | 24 | 基础类型定义 |
| `include/secs/core/buffer.hpp` | 69 | FixedBuffer 接口 |
| `include/secs/core/error.hpp` | 35 | errc 枚举与 error_code 集成 |
| `include/secs/core/event.hpp` | 63 | Event 协程同步原语接口 |
| `include/secs/core/log.hpp` | 28 | 日志封装接口（spdlog 隔离） |
| `src/core/buffer.cpp` | 256 | FixedBuffer 实现 |
| `src/core/error.cpp` | 54 | error_category 实现 |
| `src/core/event.cpp` | 115 | Event 实现 |
| `src/core/log.cpp` | 59 | 日志封装实现 |
