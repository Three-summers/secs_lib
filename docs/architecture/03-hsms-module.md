# HSMS 模块详细实现原理

> 文档生成日期：2026-01-06
> 基于源码版本：当前 main 分支
> 对应标准：SEMI E37（HSMS - High-Speed SECS Message Services）

## 1. 模块概述

`secs::hsms` 模块实现 HSMS-SS（HSMS Single Session）传输层，提供：

- **消息封装**：`Message` / `Header` 结构
- **TCP 连接**：`Connection` 分帧读写
- **会话管理**：`Session` 状态机 + 控制消息处理

```
┌─────────────────────────────────────────────────────────────────────┐
│                        secs::hsms 模块                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                    Session（会话层）                         │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │   │
│  │  │ 状态机      │  │ 控制消息    │  │ 定时器              │  │   │
│  │  │ disconnected│  │ SELECT      │  │ T3/T5/T6/T7/T8      │  │   │
│  │  │ connected   │  │ DESELECT    │  │ LINKTEST 周期       │  │   │
│  │  │ selected    │  │ LINKTEST    │  │                     │  │   │
│  │  └─────────────┘  │ SEPARATE    │  └─────────────────────┘  │   │
│  │                   │ REJECT      │                            │   │
│  │                   └─────────────┘                            │   │
│  └───────────────────────────▲─────────────────────────────────┘   │
│                              │                                      │
│  ┌───────────────────────────┴─────────────────────────────────┐   │
│  │                    Connection（连接层）                      │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │   │
│  │  │ TCP 分帧    │  │ 写队列      │  │ T8 超时              │  │   │
│  │  │ Length(4B)  │  │ control优先 │  │ 字符间隔             │  │   │
│  │  │ +Header(10B)│  │ data次之    │  │                     │  │   │
│  │  │ +Body       │  │             │  │                     │  │   │
│  │  └─────────────┘  └─────────────┘  └─────────────────────┘  │   │
│  └───────────────────────────▲─────────────────────────────────┘   │
│                              │                                      │
│  ┌───────────────────────────┴─────────────────────────────────┐   │
│  │                    Message（消息层）                         │   │
│  │  Header(10B) + Body(0~16MB)                                  │   │
│  │  encode_frame() / decode_frame()                             │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 2. HSMS 消息格式（SEMI E37）

### 2.1 TCP 帧结构

```
┌─────────────────────────────────────────────────────────────────────┐
│                    HSMS TCP 帧格式                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌──────────────┬──────────────┬─────────────────────────────────┐ │
│  │ Message      │   Header     │         Message Text            │ │
│  │ Length (4B)  │   (10B)      │         (0 ~ 16MB)              │ │
│  │ big-endian   │              │                                 │ │
│  └──────────────┴──────────────┴─────────────────────────────────┘ │
│                                                                     │
│  Message Length = Header(10) + Body(N)                             │
│                                                                     │
│  约束：                                                             │
│  ├── kHeaderSize = 10                                               │
│  ├── kLengthFieldSize = 4                                           │
│  ├── kMaxPayloadSize = 16MB（防止恶意长度字段）                     │
│  └── 最小帧长度 = 4 + 10 = 14 字节                                  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.2 Header 结构（10 字节）

```
┌─────────────────────────────────────────────────────────────────────┐
│                    HSMS Header 布局                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Byte Offset   Field           Size    Description                  │
│  ─────────────────────────────────────────────────────────────────  │
│  0-1           SessionID       2B      会话标识（大端序）            │
│  2             HeaderByte2     1B      数据消息: W(1)+Stream(7)     │
│                                        控制消息: 状态码/reason      │
│  3             HeaderByte3     1B      数据消息: Function           │
│                                        控制消息: 保留(0)            │
│  4             PType           1B      协议类型 (0x00=SECS-II)      │
│  5             SType           1B      消息类型 (见下表)            │
│  6-9           SystemBytes     4B      事务标识（大端序）            │
│                                                                     │
│  字节级布局：                                                       │
│  ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐    │
│  │  0  │  1  │  2  │  3  │  4  │  5  │  6  │  7  │  8  │  9  │    │
│  ├─────┴─────┼─────┼─────┼─────┼─────┼─────┴─────┴─────┴─────┤    │
│  │ SessionID │ HB2 │ HB3 │PType│SType│      SystemBytes      │    │
│  └───────────┴─────┴─────┴─────┴─────┴───────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.3 SType 消息类型

```
┌─────────────────────────────────────────────────────────────────────┐
│                    SType 消息类型定义                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  SType   值     名称          说明              SessionID          │
│  ─────────────────────────────────────────────────────────────────  │
│  data    0x00   数据消息      SECS-II payload   DeviceID (0~32767) │
│                                                                     │
│  控制消息（SessionID 通常为 0xFFFF）：                              │
│  select_req    0x01   选择请求      建立会话                        │
│  select_rsp    0x02   选择响应      HB2=status (0=OK)              │
│  deselect_req  0x03   取消选择请求  退出 selected                   │
│  deselect_rsp  0x04   取消选择响应  HB2=status (0=OK)              │
│  linktest_req  0x05   链路测试请求  心跳                            │
│  linktest_rsp  0x06   链路测试响应  心跳回应                        │
│  reject_req    0x07   拒绝请求      HB2=reason, body=被拒header    │
│  separate_req  0x09   分离请求      立即断开                        │
│                                                                     │
│  HeaderByte2 复用说明：                                             │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  数据消息:      [W-bit(1)] [Stream(7)]                      │    │
│  │                 W=1 表示需要回应                             │    │
│  │                                                             │    │
│  │  Select.rsp:    [status(8)]  0=接受, 其他=拒绝原因          │    │
│  │  Deselect.rsp:  [status(8)]  0=接受, 其他=拒绝原因          │    │
│  │  Reject.req:    [reason(8)]  拒绝原因码                     │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 3. Message 编解码

### 3.1 编码流程

```
┌─────────────────────────────────────────────────────────────────────┐
│                    encode_frame(msg, out) 流程                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. 校验：                                                          │
│     ├── PType == 0x00 (SECS-II)                                     │
│     └── body.size() <= kMaxPayloadSize - kHeaderSize                │
│                                                                     │
│  2. 计算 payload_len = kHeaderSize + body.size()                    │
│                                                                     │
│  3. 分配输出缓冲区：out.resize(4 + payload_len)                     │
│                                                                     │
│  4. 写入数据：                                                      │
│     ┌────────────────────────────────────────────────────────────┐ │
│     │  offset 0-3:   write_u32_be(payload_len)                   │ │
│     │  offset 4-5:   write_u16_be(session_id)                    │ │
│     │  offset 6:     header_byte2                                │ │
│     │  offset 7:     header_byte3                                │ │
│     │  offset 8:     p_type                                      │ │
│     │  offset 9:     s_type                                      │ │
│     │  offset 10-13: write_u32_be(system_bytes)                  │ │
│     │  offset 14+:   memcpy(body)                                │ │
│     └────────────────────────────────────────────────────────────┘ │
│                                                                     │
│  输出格式：                                                         │
│  ┌──────────┬──────────────────────────────────────────────────┐   │
│  │ Length   │  Header(10B)  +  Body(NB)                        │   │
│  │  (4B)    │                                                  │   │
│  └──────────┴──────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 3.2 解码流程

```
┌─────────────────────────────────────────────────────────────────────┐
│                    decode_frame(frame, out, consumed) 流程          │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. 读取 payload_len = read_u32_be(frame[0:4])                      │
│     ├── 校验 payload_len >= kHeaderSize                             │
│     └── 校验 payload_len <= kMaxPayloadSize                         │
│                                                                     │
│  2. 校验帧完整性：frame.size() >= 4 + payload_len                   │
│                                                                     │
│  3. 调用 decode_payload(frame[4:4+payload_len], out)                │
│     │                                                               │
│     └── 解析 Header：                                               │
│         ┌────────────────────────────────────────────────────────┐ │
│         │  session_id  = read_u16_be(p[0:2])                     │ │
│         │  header_byte2 = p[2]                                   │ │
│         │  header_byte3 = p[3]                                   │ │
│         │  p_type       = p[4]  (校验 == 0x00)                   │ │
│         │  s_type       = p[5]  (允许未知值，供上层 Reject)      │ │
│         │  system_bytes = read_u32_be(p[6:10])                   │ │
│         │  body         = p[10:]                                 │ │
│         └────────────────────────────────────────────────────────┘ │
│                                                                     │
│  4. consumed = 4 + payload_len                                      │
│                                                                     │
│  注意：未知 SType 不再作为解码错误，允许解析并保留原始值            │
│        供上层发送 Reject.req                                        │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 3.3 控制消息构造助手

```
┌─────────────────────────────────────────────────────────────────────┐
│                    控制消息工厂函数                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  // SELECT 握手                                                     │
│  make_select_req(session_id, system_bytes)                          │
│  make_select_rsp(session_id, status, system_bytes)                  │
│                                                                     │
│  // DESELECT                                                        │
│  make_deselect_req(session_id, system_bytes)                        │
│  make_deselect_rsp(session_id, status, system_bytes)                │
│                                                                     │
│  // LINKTEST 心跳                                                   │
│  make_linktest_req(session_id, system_bytes)                        │
│  make_linktest_rsp(session_id, system_bytes)                        │
│                                                                     │
│  // 拒绝                                                            │
│  make_reject_req(reason_code, rejected_header)                      │
│  -> body 包含被拒绝消息的 10B header                                │
│                                                                     │
│  // 分离                                                            │
│  make_separate_req(session_id, system_bytes)                        │
│                                                                     │
│  // 数据消息                                                        │
│  make_data_message(session_id, stream, function, w_bit,             │
│                    system_bytes, body)                              │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 4. Connection 连接层

### 4.1 设计职责

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Connection 职责划分                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Connection 只做"分帧 + 读写串行化"，不关心协议状态机：             │
│                                                                     │
│  1. TCP 分帧读取                                                    │
│     ├── 读 4B 长度字段                                              │
│     ├── 先读 10B Header，再直读 Body 到 Message::body               │
│     └── T8 超时控制                                                 │
│                                                                     │
│  2. 消息写入串行化                                                  │
│     ├── 多协程可并发调用 async_write_message                        │
│     ├── 内部排队，单协程 writer_loop_ 串行写出                      │
│     └── 控制消息优先于数据消息                                      │
│                                                                     │
│  3. data 写门禁                                                     │
│     ├── NOT_SELECTED 状态下可禁用 data 写入                         │
│     └── 避免控制流期间 data 抢写                                    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 4.2 写队列优先级

```
┌─────────────────────────────────────────────────────────────────────┐
│                    写队列优先级机制                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  两个队列：控制消息优先                                             │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  control_queue_  ──────────────┐                            │   │
│  │  (SELECT/DESELECT/LINKTEST)    │                            │   │
│  │                                ▼                            │   │
│  │                         ┌──────────────┐                    │   │
│  │  data_queue_     ──────>│ writer_loop_ │──> TCP socket      │   │
│  │  (数据消息)              └──────────────┘                    │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  writer_loop_ 处理顺序：                                            │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  while (!stop_requested_) {                                 │    │
│  │      co_await write_ready_.async_wait();                    │    │
│  │                                                             │    │
│  │      // 优先处理控制消息                                    │    │
│  │      while (!control_queue_.empty()) {                      │    │
│  │          auto req = control_queue_.front();                 │    │
│  │          control_queue_.pop_front();                        │    │
│  │          co_await stream_->async_write_all(req->frame);     │    │
│  │          req->done.set();                                   │    │
│  │      }                                                      │    │
│  │                                                             │    │
│  │      // 再处理数据消息                                      │    │
│  │      while (!data_queue_.empty()) {                         │    │
│  │          if (!data_writes_enabled_) break;                  │    │
│  │          auto req = data_queue_.front();                    │    │
│  │          data_queue_.pop_front();                           │    │
│  │          co_await stream_->async_write_all(req->frame);     │    │
│  │          req->done.set();                                   │    │
│  │      }                                                      │    │
│  │  }                                                          │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  data 写门禁：                                                      │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  disable_data_writes(reason):                               │    │
│  │    data_writes_enabled_ = false;                            │    │
│  │    // 快速失败队列中的 data 请求                            │    │
│  │    for (req : data_queue_) req->ec = reason; req->done.set();│   │
│  │                                                             │    │
│  │  enable_data_writes():                                      │    │
│  │    data_writes_enabled_ = true;                             │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 4.3 T8 超时处理

```
┌─────────────────────────────────────────────────────────────────────┐
│                    T8 网络字符间隔超时                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  T8 定义：同一帧内，连续字节之间的最大允许间隔                      │
│                                                                     │
│  实现策略：                                                         │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  async_read_exactly(dst, frame_started):                    │    │
│  │                                                             │    │
│  │    while (remaining > 0) {                                  │    │
│  │        if (frame_started && T8 > 0) {                       │    │
│  │            // 帧已开始，启用 T8 超时                        │    │
│  │            auto [ec, n] = co_await async_read_some_with_t8();│   │
│  │            if (ec == timeout) return T8 超时错误;           │    │
│  │        } else {                                             │    │
│  │            // 等待帧首字节，不限时                          │    │
│  │            auto [ec, n] = co_await stream_->async_read_some();│  │
│  │        }                                                    │    │
│  │                                                             │    │
│  │        frame_started = true;  // 收到首字节后标记           │    │
│  │        remaining -= n;                                      │    │
│  │    }                                                        │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  时序图：                                                           │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  等待帧        │  帧内字节接收                              │    │
│  │  (无超时)      │  (T8 超时控制)                             │    │
│  │                │                                            │    │
│  │  ────────────>│<─ B1 ─><─ B2 ─><─ B3 ─>...                 │    │
│  │               ^     ^     ^                                 │    │
│  │               │     │     │                                 │    │
│  │               │   <=T8  <=T8                                │    │
│  │          frame_started=true                                 │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 5. Session 会话层

### 5.1 状态机

```
┌─────────────────────────────────────────────────────────────────────┐
│                    HSMS-SS 会话状态机                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│                    ┌───────────────┐                                │
│                    │  disconnected │                                │
│                    └───────┬───────┘                                │
│                            │                                        │
│            TCP connect     │  TCP accept                            │
│                            ▼                                        │
│                    ┌───────────────┐                                │
│                    │   connected   │                                │
│                    └───────┬───────┘                                │
│                            │                                        │
│      Active: send SELECT.req                                        │
│      Passive: recv SELECT.req, send SELECT.rsp                      │
│                            │                                        │
│                            ▼                                        │
│                    ┌───────────────┐                                │
│              ┌────>│   selected    │<────┐                          │
│              │     └───────┬───────┘     │                          │
│              │             │             │                          │
│    SELECT.req│    DESELECT │    SEPARATE │                          │
│    成功      │             ▼             │                          │
│              │     ┌───────────────┐     │                          │
│              │     │ not_selected  │     │                          │
│              │     │  (connected)  │─────┘                          │
│              │     └───────────────┘                                │
│              │                                                      │
│              └──────────────────────────────────────────────────────│
│                                                                     │
│  状态转换触发条件：                                                 │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  disconnected -> connected:  TCP 建连成功                   │    │
│  │  connected -> selected:      SELECT 握手成功                │    │
│  │  selected -> not_selected:   DESELECT 成功                  │    │
│  │  selected -> disconnected:   SEPARATE / 网络错误 / T超时    │    │
│  │  not_selected -> selected:   重新 SELECT                    │    │
│  │  * -> disconnected:          stop() / 断线                  │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 5.2 定时器配置

```
┌─────────────────────────────────────────────────────────────────────┐
│                    HSMS 定时器（SessionOptions）                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  定时器    默认值    用途                                           │
│  ─────────────────────────────────────────────────────────────────  │
│  T3        45s       数据消息回复超时（Request-Response）           │
│  T5        10s       重连延迟 / SEPARATE 后退避                     │
│  T6        5s        控制事务超时（SELECT/DESELECT/LINKTEST）       │
│  T7        10s       被动端等待 SELECT 超时                         │
│  T8        5s        网络字符间隔超时（TCP 读）                      │
│                                                                     │
│  LINKTEST 相关：                                                    │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  linktest_interval:  LINKTEST 周期（0=禁用自动 LINKTEST）   │    │
│  │  linktest_max_consecutive_failures:  连续失败阈值           │    │
│  │                      达到后断线（默认 1：一次失败即断）     │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  时序示意（以 T3 为例）：                                           │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  Host                              Equipment                │    │
│  │    │                                    │                   │    │
│  │    │──── S1F1 (W=1) ──────────────────>│                   │    │
│  │    │         start T3                   │                   │    │
│  │    │                                    │ processing...     │    │
│  │    │<─── S1F2 ─────────────────────────│                   │    │
│  │    │         cancel T3                  │                   │    │
│  │    │                                    │                   │    │
│  │  或者：                                                     │    │
│  │    │                                    │                   │    │
│  │    │──── S1F1 (W=1) ──────────────────>│                   │    │
│  │    │         start T3                   │                   │    │
│  │    │              ...T3 expires...      │                   │    │
│  │    │         返回 timeout               │                   │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 5.2.1 控制消息观测（on_control_event）

`hsms::SessionOptions` 提供可选回调 `on_control_event`，用于观测 HSMS 控制消息（`SType != data`）的收发事件，便于联调日志与指标系统接入。

- 触发范围：仅控制消息（SELECT/DESELECT/LINKTEST/REJECT/SEPARATE 等），数据消息不触发
- 方向：`ControlDirection::{rx, tx}`（接收/发送）
- 字段：透出 `session_id/system_bytes/header_byte2/header_byte3`（字节级，不做语义解释）
- Reject.req：当 body 恰好为 10B 时，`has_rejected_header=true` 且解析出 `rejected_header`
- 注意：回调仅用于观测/统计；回调抛出的异常会被捕获并忽略，不影响会话可用性

### 5.3 Active 模式流程

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Active 模式（客户端）流程                        │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  async_open_active(endpoint) 流程：                                 │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  1. connection_.async_connect(endpoint)                     │    │
│  │     └── TCP 三次握手                                        │    │
│  │                                                             │    │
│  │  2. start_reader_()                                         │    │
│  │     └── 启动 reader_loop_ 协程                              │    │
│  │                                                             │    │
│  │  3. async_control_transaction_(SELECT.req, SELECT.rsp, T6)  │    │
│  │     ├── 发送 SELECT.req                                     │    │
│  │     ├── 等待 SELECT.rsp (T6 超时)                           │    │
│  │     └── 校验 status == 0                                    │    │
│  │                                                             │    │
│  │  4. set_selected_()                                         │    │
│  │     ├── state_ = selected                                   │    │
│  │     ├── ++selected_generation_                              │    │
│  │     ├── selected_event_.set()                               │    │
│  │     └── connection_.enable_data_writes()                    │    │
│  │                                                             │    │
│  │  5. 启动 linktest_loop_ (如果配置了 linktest_interval)      │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  async_run_active(endpoint) - 自动重连主循环：                      │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  while (!stop_requested_) {                                 │    │
│  │      auto ec = co_await async_open_active(endpoint);        │    │
│  │      if (ec && !auto_reconnect) co_return ec;               │    │
│  │                                                             │    │
│  │      // 等待断线                                            │    │
│  │      co_await disconnected_event_.async_wait();             │    │
│  │                                                             │    │
│  │      // T5 退避延迟                                         │    │
│  │      co_await async_sleep(T5);                              │    │
│  │  }                                                          │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 5.4 Passive 模式流程

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Passive 模式（服务端）流程                       │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  async_open_passive(socket) 流程：                                  │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  1. 接管 socket 构造 Connection                             │    │
│  │                                                             │    │
│  │  2. start_reader_()                                         │    │
│  │     └── 启动 reader_loop_ 协程                              │    │
│  │                                                             │    │
│  │  3. 等待 SELECT.req (T7 超时)                               │    │
│  │     ├── reader_loop_ 收到 SELECT.req                        │    │
│  │     └── 超时未收到 -> 返回错误                              │    │
│  │                                                             │    │
│  │  4. 发送 SELECT.rsp (status=0 接受 / 非0 拒绝)              │    │
│  │     └── 由 passive_accept_select 配置决定                   │    │
│  │                                                             │    │
│  │  5. set_selected_()                                         │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  reader_loop_ 控制消息处理：                                        │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  // 控制消息：先触发可选观测回调（on_control_event）         │    │
│  │  emit_control_event(rx, msg);                               │    │
│  │                                                             │    │
│  │  switch (msg.s_type) {                                      │    │
│  │      case select_req:                                       │    │
│  │          // 被动端处理                                      │    │
│  │          send SELECT.rsp                                    │    │
│  │          break;                                             │    │
│  │                                                             │    │
│  │      case select_rsp / deselect_rsp / linktest_rsp:         │    │
│  │          // 唤醒 pending_ 中的等待者                        │    │
│  │          fulfill_pending_(msg);                             │    │
│  │          break;                                             │    │
│  │                                                             │    │
│  │      case linktest_req:                                     │    │
│  │          // 自动回应                                        │    │
│  │          send LINKTEST.rsp                                  │    │
│  │          break;                                             │    │
│  │                                                             │    │
│  │      case deselect_req:                                     │    │
│  │          send DESELECT.rsp                                  │    │
│  │          set_not_selected_()  // 进入 NOT_SELECTED          │    │
│  │          break;                                             │    │
│  │                                                             │    │
│  │      case separate_req:                                     │    │
│  │          on_disconnected_()   // 立即断线                   │    │
│  │          break;                                             │    │
│  │                                                             │    │
│  │      case reject_req:                                       │    │
│  │          // Reject.req：不改变状态；仅用于联调观测           │    │
│  │          break;                                             │    │
│  │                                                             │    │
│  │      default:                                               │    │
│  │          // 未知控制类型：回 Reject.req(reason=1)            │    │
│  │          send Reject.req                                    │    │
│  │          break;                                             │    │
│  │  }                                                          │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 5.5 数据消息收发

```
┌─────────────────────────────────────────────────────────────────────┐
│                    数据消息收发 API                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  async_send(msg):                                                   │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  // 无需等待回应                                            │    │
│  │  co_await connection_.async_write_message(msg);             │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  async_receive_data(timeout):                                       │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  // 控制消息由 reader_loop_ 内部处理，只返回数据消息        │    │
│  │  while (inbound_data_.empty()) {                            │    │
│  │      auto ec = co_await inbound_event_.async_wait(timeout); │    │
│  │      if (ec) co_return {ec, {}};                            │    │
│  │  }                                                          │    │
│  │  auto msg = inbound_data_.front();                          │    │
│  │  inbound_data_.pop_front();                                 │    │
│  │  co_return {ok, msg};                                       │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  async_request_data(stream, function, body, timeout):               │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  // 发送 W=1 的数据消息，等待同 SystemBytes 的回应          │    │
│  │  auto system_bytes = allocate_system_bytes();               │    │
│  │  auto msg = make_data_message(session_id_, stream, function,│    │
│  │                               true, system_bytes, body);    │    │
│  │                                                             │    │
│  │  auto pending = make_shared<Pending>(SType::data);          │    │
│  │  pending_[system_bytes] = pending;                          │    │
│  │                                                             │    │
│  │  co_await async_send(msg);                                  │    │
│  │  auto ec = co_await pending->ready.async_wait(timeout);     │    │
│  │                                                             │    │
│  │  pending_.erase(system_bytes);                              │    │
│  │  co_return {ec, pending->response};                         │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 6. SystemBytes 事务匹配

```
┌─────────────────────────────────────────────────────────────────────┐
│                    SystemBytes 事务匹配机制                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  SystemBytes 是 HSMS 的"请求-响应关联标识"：                        │
│                                                                     │
│  1. 分配：                                                          │
│     ┌────────────────────────────────────────────────────────────┐ │
│     │  std::atomic<uint32_t> system_bytes_{1};                   │ │
│     │                                                            │ │
│     │  uint32_t allocate_system_bytes() {                        │ │
│     │      return system_bytes_.fetch_add(1);                    │ │
│     │  }                                                         │ │
│     └────────────────────────────────────────────────────────────┘ │
│                                                                     │
│  2. 请求-响应匹配：                                                 │
│     ┌────────────────────────────────────────────────────────────┐ │
│     │  unordered_map<uint32_t, shared_ptr<Pending>> pending_;    │ │
│     │                                                            │ │
│     │  发送请求时：                                              │ │
│     │    pending_[system_bytes] = {expected_stype, event, ...};  │ │
│     │                                                            │ │
│     │  收到响应时（reader_loop_）：                              │ │
│     │    if (auto it = pending_.find(msg.system_bytes)) {        │ │
│     │        it->second->response = msg;                         │ │
│     │        it->second->ready.set();  // 唤醒等待者             │ │
│     │    }                                                       │ │
│     └────────────────────────────────────────────────────────────┘ │
│                                                                     │
│  匹配流程图：                                                       │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  Request                           Response                 │    │
│  │    │                                   │                    │    │
│  │    │  SB=100                           │                    │    │
│  │    ├──────────────────────────────────>│                    │    │
│  │    │       pending_[100] = {...}       │                    │    │
│  │    │                                   │                    │    │
│  │    │                    SB=100         │                    │    │
│  │    │<──────────────────────────────────│                    │    │
│  │    │   pending_[100]->ready.set()      │                    │    │
│  │    │                                   │                    │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 7. LINKTEST 心跳机制

```
┌─────────────────────────────────────────────────────────────────────┐
│                    LINKTEST 心跳机制                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  linktest_loop_(generation) 协程：                                  │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  uint32_t consecutive_failures = 0;                         │    │
│  │                                                             │    │
│  │  while (is_selected() && generation == selected_generation_) {│  │
│  │      co_await async_sleep(linktest_interval);               │    │
│  │                                                             │    │
│  │      auto ec = co_await async_linktest();                   │    │
│  │      if (ec) {                                              │    │
│  │          ++consecutive_failures;                            │    │
│  │          if (consecutive_failures >= max_consecutive_failures) {│ │
│  │              on_disconnected_(ec);  // 断线                 │    │
│  │              break;                                         │    │
│  │          }                                                  │    │
│  │      } else {                                               │    │
│  │          consecutive_failures = 0;  // 重置计数             │    │
│  │      }                                                      │    │
│  │  }                                                          │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  时序图：                                                           │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  Session A                        Session B                 │    │
│  │     │                                  │                    │    │
│  │     │──── LINKTEST.req ───────────────>│                    │    │
│  │     │                                  │                    │    │
│  │     │<─── LINKTEST.rsp ────────────────│                    │    │
│  │     │   consecutive_failures = 0       │                    │    │
│  │     │                                  │                    │    │
│  │     │  (linktest_interval later)       │                    │    │
│  │     │                                  │                    │    │
│  │     │──── LINKTEST.req ───────────────>│                    │    │
│  ���     │         (T6 timeout)             │                    │    │
│  │     │   consecutive_failures = 1       │                    │    │
│  │     │                                  │                    │    │
│  │     │  if (failures >= max) -> disconnect                   │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 8. 源文件清单

| 文件 | 行数 | 说明 |
|------|------|------|
| `include/secs/hsms/message.hpp` | 131 | Message/Header 定义 |
| `include/secs/hsms/connection.hpp` | 134 | Connection 接口 |
| `include/secs/hsms/session.hpp` | 224 | Session 接口 |
| `include/secs/hsms/timer.hpp` | 34 | 定时器工具 |
| `src/hsms/message.cpp` | 279 | 消息编解码实现 |
| `src/hsms/connection.cpp` | 457 | Connection 实现 |
| `src/hsms/session.cpp` | 801 | Session 状态机实现 |
| `src/hsms/timer.cpp` | 48 | 定时器实现 |
