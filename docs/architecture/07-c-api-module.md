# C_API 模块详细实现原理

> 文档生成日期：2026-01-07
> 基于源码版本：当前 main 分支

## 1. 模块概述

`secs::c_api` 是整个 secs_lib 的 C 语言绑定层，使纯 C 工程能通过标准 C ABI 调用本库能力：

- **不透明句柄**：隐藏 C++ 类型，暴露 opaque handle
- **错误映射**：`secs_error_t` 对应 `std::error_code`
- **内存管理**：`secs_malloc/secs_free` 统一分配/释放
- **阻塞桥接**：`run_blocking()` 将协程结果同步返回 C 调用方
- **异常隔离**：C++ 异常禁止跨越 C 边界

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          C_API 模块架构                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                        C 语言调用方                              │   │
│  │  #include <secs/c_api.h>                                        │   │
│  └──────────────────────────────▲──────────────────────────────────┘   │
│                                 │                                       │
│  ═══════════════════════════════╪═══════════════════════════════════   │
│                            C ABI 边界                                   │
│  ═══════════════════════════════╪═══════════════════════════════════   │
│                                 │                                       │
│  ┌──────────────────────────────┴──────────────────────────────────┐   │
│  │                     c_api.cpp 实现层                             │   │
│  │                                                                  │   │
│  │  ┌────────────────┐  ┌────────────────┐  ┌──────────────────┐   │   │
│  │  │ guard_error()  │  │ run_blocking() │  │ secs_error_t     │   │   │
│  │  │ 异常捕获转换   │  │ 协程→阻塞桥接  │  │ 错误码映射       │   │   │
│  │  └────────────────┘  └────────────────┘  └──────────────────┘   │   │
│  │                                                                  │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │             不透明句柄 (Opaque Handles)                     │ │   │
│  │  │  ┌──────────────┐  ┌──────────────┐  ┌────────────────┐   │ │   │
│  │  │  │secs_context  │  │secs_ii_item  │  │secs_sml_runtime│   │ │   │
│  │  │  │  io_context  │  │  ii::Item    │  │  sml::Runtime  │   │ │   │
│  │  │  │  io_thread   │  │              │  │                │   │ │   │
│  │  │  └──────────────┘  └──────────────┘  └────────────────┘   │ │   │
│  │  │  ┌──────────────┐  ┌──────────────┐  ┌────────────────┐   │ │   │
│  │  │  │secs_hsms_    │  │secs_hsms_    │  │secs_protocol_  │   │ │   │
│  │  │  │connection    │  │session       │  │session         │   │ │   │
│  │  │  │  Connection  │  │  Session*    │  │  protocol_state│   │ │   │
│  │  │  └──────────────┘  └──────────────┘  └────────────────┘   │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                 │                                       │
│  ┌──────────────────────────────┴──────────────────────────────────┐   │
│  │                   C++ 底层模块                                   │   │
│  │  secs::core | secs::ii | secs::sml | secs::hsms | secs::protocol│   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 2. 设计目标与约束

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        C_API 设计目标                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  1. 纯 C 可调用                                                         │
│     ├── 所有接口使用 extern "C" 声明                                    │
│     ├── 只使用 C 语言类型（int, uint8_t, size_t 等）                    │
│     └── C++ 类型通过 opaque handle 隐藏                                 │
│                                                                         │
│  2. 异常安全                                                            │
│     ├── C++ 异常禁止跨越 C ABI 边界                                     │
│     ├── 所有导出函数用 guard_error() 包裹                               │
│     └── 异常转换为 SECS_C_API_EXCEPTION 或 SECS_C_API_OUT_OF_MEMORY     │
│                                                                         │
│  3. 内存管理清晰                                                        │
│     ├── 库分配的内存统一使用 secs_malloc/secs_free                      │
│     ├── 避免跨 CRT/运行时的堆不匹配问题                                 │
│     └── 每个 create 有对应的 destroy/free                               │
│                                                                         │
│  4. 阻塞式 API                                                          │
│     ├── 网络操作在调用线程阻塞直到完成                                  │
│     ├── 内部通过 run_blocking() 将协程结果同步返回                      │
│     └── 禁止在 io 线程调用阻塞 API（返回 WRONG_THREAD）                 │
│                                                                         │
│  5. 错误码兼容 std::error_code                                          │
│     ├── secs_error_t{value, category} 一一对应                          │
│     ├── 支持本库所有错误域：secs.core, secs.ii, secs.secs1 等          │
│     └── secs.c_api 为 C 层自身错误                                      │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 3. 不透明句柄定义

### 3.1 句柄结构（c_api.cpp 内部定义）

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    不透明句柄内部结构                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  struct secs_context {                                                  │
│      asio::io_context ioc;                                              │
│      asio::executor_work_guard<...> work;   // 保持 ioc.run() 不退出    │
│      std::thread io_thread;                  // 单一 io 线程            │
│      std::thread::id io_thread_id;           // 用于检测 WRONG_THREAD   │
│  };                                                                     │
│                                                                         │
│  struct secs_ii_item {                                                  │
│      secs::ii::Item item;                    // 包装 SECS-II 数据项     │
│  };                                                                     │
│                                                                         │
│  struct secs_sml_runtime {                                              │
│      secs::sml::Runtime rt;                  // SML 脚本运行时          │
│  };                                                                     │
│                                                                         │
│  struct secs_hsms_connection {                                          │
│      secs::hsms::Connection conn;            // HSMS TCP 连接封装       │
│  };                                                                     │
│                                                                         │
│  struct secs_hsms_session {                                             │
│      secs_context* ctx;                                                 │
│      secs::hsms::SessionOptions options;                                │
│      std::shared_ptr<secs::hsms::Session> sess;  // shared_ptr 防 UAF   │
│  };                                                                     │
│                                                                         │
│  struct protocol_state {                                                │
│      secs_context* ctx;                                                 │
│      std::shared_ptr<secs::hsms::Session> hsms_keepalive;               │
│      std::unique_ptr<secs::protocol::Session> sess;                     │
│      secs::core::Event run_done;             // 等待 async_run 结束     │
│  };                                                                     │
│                                                                         │
│  struct secs_protocol_session {                                         │
│      std::shared_ptr<protocol_state> state;  // shared_ptr 防 UAF       │
│  };                                                                     │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 3.2 为什么使用 shared_ptr

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    shared_ptr 防 UAF 机制                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  问题场景：                                                             │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  Thread A (调用方)           Thread B (io 线程)                  │   │
│  │  ─────────────────           ─────────────────                   │   │
│  │  secs_hsms_session_stop()    处理 stop 请求...                   │   │
│  │      └── asio::post(stop)                                        │   │
│  │  secs_hsms_session_destroy() ← 若直接 delete，                   │   │
│  │      └── delete sess            Thread B 访问已释放对象（UAF）   │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  解决方案：                                                             │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  hsms_stop_on_io_thread() {                                      │   │
│  │      auto s = sess->sess;   // 复制 shared_ptr                   │   │
│  │      asio::post(ctx->ioc, [s]() { s->stop(); });                 │   │
│  │  }                                                               │   │
│  │                                                                  │   │
│  │  // 即使 destroy() 释放了 secs_hsms_session，                    │   │
│  │  // lambda 持有的 s 仍然保持 Session 存活，直到 stop() 完成      │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 4. 错误处理机制

### 4.1 secs_error_t 结构

```cpp
typedef struct secs_error {
    int value;           // 错误码值
    const char *category; // 错误域名（静态字符串，生命周期贯穿进程）
} secs_error_t;
```

### 4.2 错误域映射

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    错误域映射关系                                       │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  category 字符串              对应 C++ error_category                   │
│  ─────────────────────────    ───────────────────────────────────────   │
│  "secs.c_api"                 C API 自身错误（见下表）                  │
│  "secs.core"                  secs::core::error_category()              │
│  "secs.secs1"                 secs::secs1::error_category()             │
│  "secs.ii"                    secs::ii::error_category()                │
│  "sml.lexer"                  secs::sml::lexer_error_category()         │
│  "sml.parser"                 secs::sml::parser_error_category()        │
│  "system"                     std::system_category()                    │
│  "generic"                    std::generic_category()                   │
│                                                                         │
│  secs.c_api 错误码：                                                    │
│  ┌────────────────────────────────┬───────────────────────────────────┐ │
│  │ SECS_C_API_OK = 0              │ 成功                              │ │
│  │ SECS_C_API_INVALID_ARGUMENT =1 │ 非法参数（NULL 指针等）           │ │
│  │ SECS_C_API_NOT_FOUND = 2       │ 未找到（如 SML 消息不存在）       │ │
│  │ SECS_C_API_OUT_OF_MEMORY = 3   │ 内存分配失败                      │ │
│  │ SECS_C_API_WRONG_THREAD = 4    │ 在 io 线程调用阻塞 API            │ │
│  │ SECS_C_API_EXCEPTION = 5       │ C++ 异常被捕获                    │ │
│  └────────────────────────────────┴───────────────────────────────────┘ │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 4.3 guard_error() 异常捕获

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    guard_error() 实现原理                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  template <class Fn>                                                    │
│  secs_error_t guard_error(Fn&& fn) noexcept {                           │
│      try {                                                              │
│          return fn();                 // 执行业务逻辑                   │
│      } catch (const std::bad_alloc&) {                                  │
│          return c_api_err(SECS_C_API_OUT_OF_MEMORY);                    │
│      } catch (...) {                                                    │
│          return c_api_err(SECS_C_API_EXCEPTION);                        │
│      }                                                                  │
│  }                                                                      │
│                                                                         │
│  使用示例：                                                             │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  secs_error_t secs_ii_item_create_list(secs_ii_item_t** out) {   │   │
│  │      return guard_error([&]() -> secs_error_t {                  │   │
│  │          // 可能抛异常的 C++ 代码                                │   │
│  │          return new_item(secs::ii::Item::list({}), out);         │   │
│  │      });                                                         │   │
│  │  }                                                               │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 5. 阻塞式调用桥接

### 5.1 run_blocking() 实现

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    run_blocking() 协程→阻塞桥接                         │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  调用线程                              io 线程                          │
│  ──────────                            ─────────                        │
│                                                                         │
│  run_blocking(ctx, awaitable, out)                                      │
│      │                                                                  │
│      ├─> 检查：ctx != nullptr ?                                         │
│      │   └── NO: 返回 INVALID_ARGUMENT                                  │
│      │                                                                  │
│      ├─> 检查：is_io_thread(ctx) ?                                      │
│      │   └── YES: 返回 WRONG_THREAD（防死锁）                           │
│      │                                                                  │
│      ├─> 创建同步原语：                                                 │
│      │   mutex mu; condition_variable cv; bool done=false;              │
│      │                                                                  │
│      ├─> asio::co_spawn(ctx->ioc, awaitable,                            │
│      │       [&](exception_ptr e, Result r) {                           │
│      │           lock_guard lk(mu);                                     │
│      │           eptr = e; result = r; done = true;  ─────────────────> │
│      │           cv.notify_one();                                       │
│      │       });                                                        │
│      │                                                                  │
│      ├─> unique_lock lk(mu);                                            │
│      │   cv.wait(lk, [&]{ return done; }); <──────────────────────────  │
│      │                                                                  │
│      ├─> 检查异常：eptr ? 返回 EXCEPTION                                │
│      │                                                                  │
│      └─> out = *result; return ok();                                    │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 5.2 WRONG_THREAD 检测

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    io 线程死锁检测                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  [[nodiscard]] bool is_io_thread(const secs_context* ctx) noexcept {    │
│      return ctx && std::this_thread::get_id() == ctx->io_thread_id;     │
│  }                                                                      │
│                                                                         │
│  死锁场景：                                                             │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  io 线程执行 handler 回调                                        │   │
│  │      └── 回调内调用 secs_hsms_session_request_data()             │   │
│  │          └── run_blocking() 等待 cv.wait()                       │   │
│  │              └── 但 io 线程正在等待自己完成 → 死锁               │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  解决：阻塞 API 开头检测 is_io_thread()，若为真则立即返回 WRONG_THREAD │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 6. 内存管理

### 6.1 分配与释放

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    内存管理约定                                         │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  分配：                                                                 │
│  void* secs_malloc(size_t n) { return std::malloc(n); }                 │
│                                                                         │
│  释放：                                                                 │
│  void secs_free(void* p) { std::free(p); }                              │
│                                                                         │
│  为什么不直接用 malloc/free？                                           │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  Windows 多 CRT 场景：                                           │   │
│  │  ├── 库（静态/动态）可能链接到不同 CRT 版本                      │   │
│  │  ├── CRT A 的 malloc 分配的内存不能用 CRT B 的 free 释放        │   │
│  │  └── 统一使用库导出的 secs_malloc/secs_free 规避此问题           │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  哪些内存需要 secs_free？                                               │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  API                           返回的需释放内容                  │   │
│  │  ─────────────────────────     ─────────────────────────────    │   │
│  │  secs_error_message()          char* 字符串                      │   │
│  │  secs_ii_encode()              uint8_t* 字节数组                 │   │
│  │  secs_ii_item_boolean_copy()   uint8_t* 布尔值数组               │   │
│  │  secs_sml_runtime_match_*      char* 消息名字符串                │   │
│  │  secs_sml_runtime_get_*        uint8_t* body 字节                │   │
│  │  secs_hsms_data_message_t      body 字段（用 _free 释放）        │   │
│  │  secs_data_message_t           body 字段（用 _free 释放）        │   │
│  │  handler 回调 out_body         必须用 secs_malloc 分配           │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 6.2 句柄生命周期

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    句柄创建与销毁配对                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  创建函数                          销毁函数                             │
│  ──────────────────────            ──────────────────────               │
│  secs_context_create()             secs_context_destroy()               │
│  secs_ii_item_create_*()           secs_ii_item_destroy()               │
│  secs_sml_runtime_create()         secs_sml_runtime_destroy()           │
│  secs_hsms_connection_create_*()   secs_hsms_connection_destroy()       │
│  secs_hsms_session_create()        secs_hsms_session_destroy()          │
│  secs_hsms_session_create_v2()     secs_hsms_session_destroy()          │
│  secs_protocol_session_create_*()  secs_protocol_session_destroy()      │
│                                                                         │
│  注意：destroy 函数内部使用 guard_void() 吞掉异常，保证不抛出           │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 7. secs_context 上下文

### 7.1 创建流程

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    secs_context_create() 流程                           │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  1. 分配 secs_context 对象                                              │
│     └── new (std::nothrow) secs_context{}                               │
│                                                                         │
│  2. 创建 work_guard                                                     │
│     ├── 防止 ioc.run() 在无任务时退出                                   │
│     └── asio::make_work_guard(ioc)                                      │
│                                                                         │
│  3. 启动 io 线程                                                        │
│     ┌─────────────────────────────────────────────────────────────┐    │
│     │  std::promise<void> started;                                 │    │
│     │  ctx->io_thread = std::thread([ctx, p]() mutable {           │    │
│     │      ctx->io_thread_id = std::this_thread::get_id();         │    │
│     │      p.set_value();   // 通知主线程 id 已记录                 │    │
│     │      ctx->ioc.run();  // 阻塞运行事件循环                     │    │
│     │  });                                                         │    │
│     │  started.get_future().wait();  // 等待 id 记录完成            │    │
│     └─────────────────────────────────────────────────────────────┘    │
│                                                                         │
│  4. 返回句柄                                                            │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 7.2 销毁流程

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    secs_context_destroy() 流程                          │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  1. ctx->work.reset()      // 释放 work_guard，允许 ioc.run() 退出      │
│  2. ctx->ioc.stop()        // 强制停止事件循环                          │
│  3. ctx->io_thread.join()  // 等待 io 线程退出                          │
│  4. delete ctx             // 释放对象                                  │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 8. SECS-II Item 封装

### 8.1 类型映射

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Item 类型映射                                        │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  C 枚举                    C++ 类型                  SECS-II 格式码     │
│  ─────────────────────     ─────────────────────     ─────────────────  │
│  SECS_II_ITEM_LIST         secs::ii::List            000 (L)            │
│  SECS_II_ITEM_ASCII        secs::ii::ASCII           010 (A)            │
│  SECS_II_ITEM_BINARY       secs::ii::Binary          001 (B)            │
│  SECS_II_ITEM_BOOLEAN      secs::ii::Boolean         001001 (BOOLEAN)   │
│  SECS_II_ITEM_I1           secs::ii::I1              011001 (I1)        │
│  SECS_II_ITEM_I2           secs::ii::I2              011010 (I2)        │
│  SECS_II_ITEM_I4           secs::ii::I4              011100 (I4)        │
│  SECS_II_ITEM_I8           secs::ii::I8              011000 (I8)        │
│  SECS_II_ITEM_U1           secs::ii::U1              101001 (U1)        │
│  SECS_II_ITEM_U2           secs::ii::U2              101010 (U2)        │
│  SECS_II_ITEM_U4           secs::ii::U4              101100 (U4)        │
│  SECS_II_ITEM_U8           secs::ii::U8              101000 (U8)        │
│  SECS_II_ITEM_F4           secs::ii::F4              100100 (F4)        │
│  SECS_II_ITEM_F8           secs::ii::F8              100000 (F8)        │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 8.2 访问模式

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Item 访问模式                                        │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  视图访问（*_view）：                                                   │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  secs_ii_item_ascii_view(item, &ptr, &n);                        │   │
│  │  // ptr 指向 item 内部数据，生命周期与 item 绑定                 │   │
│  │  // 高效：无拷贝                                                 │   │
│  │  // 适用于：ASCII, Binary, I1~I8, U1~U8, F4, F8                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  拷贝访问（*_copy）：                                                   │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  secs_ii_item_boolean_copy(item, &values, &n);                   │   │
│  │  // values 需用 secs_free 释放                                   │   │
│  │  // 原因：vector<bool> 不是连续内存，无法提供指针视图            │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  List 访问：                                                            │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  secs_ii_item_list_size(item, &n);     // 获取子元素数量         │   │
│  │  secs_ii_item_list_get(item, i, &child); // 获取第 i 个子元素    │   │
│  │  // 注意：child 是拷贝，需单独 destroy                           │   │
│  │  secs_ii_item_list_append(list, elem);   // 追加元素（拷贝语义） │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 9. HSMS 会话封装

### 9.1 会话选项

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    HSMS 会话选项映射                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  C 结构体字段                  C++ SessionOptions 字段    含义          │
│  ────────────────────────      ─────────────────────      ────────────  │
│  session_id                    session_id                 会话标识      │
│  t3_ms                         t3                         回复超时      │
│  t5_ms                         t5                         连接分离超时  │
│  t6_ms                         t6                         控制事务超时  │
│  t7_ms                         t7                         未选择超时    │
│  t8_ms                         t8                         字符间隔超时  │
│  linktest_interval_ms          linktest_interval          心跳周期      │
│  linktest_max_consecutive_     linktest_max_consecutive_  连续失败阈值  │
│    failures (v2)                 failures                               │
│  auto_reconnect                auto_reconnect             自动重连      │
│  passive_accept_select         passive_accept_select      被动接受选择  │
│                                                                         │
│  约定：0 表示使用库默认值                                               │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 9.2 连接打开模式

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    HSMS 连接打开模式                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  模式                   API                            说明             │
│  ─────                  ─────────────────────────      ────────────     │
│  主动 TCP              secs_hsms_session_open_         连接远端并       │
│                          active_ip(sess, ip, port)     发送 SELECT      │
│                                                                         │
│  被动 TCP              secs_hsms_session_open_         监听并接受       │
│                          passive_ip(sess, ip, port)    一个连接         │
│                                                                         │
│  主动 Connection       secs_hsms_session_open_         注入已有连接     │
│                          active_connection(sess, &c)   (测试用)         │
│                                                                         │
│  被动 Connection       secs_hsms_session_open_         注入已有连接     │
│                          passive_connection(sess, &c)  (测试用)         │
│                                                                         │
│  注意：Connection 注入后所有权转移，io_conn 被置空                      │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 9.3 内存连接（测试用）

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    MemoryChannel / MemoryStream                         │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  用途：无 socket 环境下的本地测试                                       │
│                                                                         │
│  创建：                                                                 │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  secs_hsms_connection_t *client, *server;                        │   │
│  │  secs_hsms_connection_create_memory_duplex(ctx, &client, &server);│   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  内部结构：                                                             │
│  ┌──────────────────────────────────────────────────────────────────┐  │
│  │           MemoryChannel c2s            MemoryChannel s2c         │  │
│  │           ┌──────────────┐             ┌──────────────┐          │  │
│  │  client ──┤ outbox       │─────────────┤ inbox        │── client │  │
│  │           │ (deque<byte>)│             │ (deque<byte>)│          │  │
│  │           └──────────────┘             └──────────────┘          │  │
│  │                                                                  │  │
│  │           ┌──────────────┐             ┌──────────────┐          │  │
│  │  server ──┤ inbox        │─────────────┤ outbox       │── server │  │
│  │           │ (deque<byte>)│             │ (deque<byte>)│          │  │
│  │           └──────────────┘             └──────────────┘          │  │
│  │                                                                  │  │
│  │  Event data_event 用于读写同步                                   │  │
│  └──────────────────────────────────────────────────────────────────┘  │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 10. 协议层会话封装

### 10.1 创建与运行

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    secs_protocol_session 生命周期                       │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  创建：                                                                 │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  secs_protocol_session_create_from_hsms(ctx, hsms_sess, ...)     │   │
│  │      │                                                           │   │
│  │      ├─> 检查 ctx 与 hsms_sess->ctx 一致                         │   │
│  │      │                                                           │   │
│  │      ├─> 创建 protocol_state                                     │   │
│  │      │   ├── ctx = ctx                                           │   │
│  │      │   ├── hsms_keepalive = hsms_sess->sess  // 防 HSMS 被提前释放│   │
│  │      │   ├── sess = new protocol::Session(...)                   │   │
│  │      │   └── run_done = Event()                                  │   │
│  │      │                                                           │   │
│  │      └─> asio::co_spawn(async_run)  // 后台启动请求-响应匹配     │   │
│  │          └── 完成时调用 run_done.set()                           │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  销毁：                                                                 │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  secs_protocol_session_destroy(sess)                             │   │
│  │      │                                                           │   │
│  │      ├─> proto_stop_on_io_thread()   // 停止 run loop            │   │
│  │      │                                                           │   │
│  │      └─> run_blocking(run_done.async_wait())  // 等待 run 结束   │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 10.2 Handler 回调机制

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    协议层 Handler 回调                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  回调签名：                                                             │
│  typedef secs_error_t (*secs_protocol_handler_fn)(                      │
│      void* user_data,                    // 用户上下文                  │
│      const secs_data_message_view_t* request, // 入站请求               │
│      uint8_t** out_body,                 // 输出响应体                  │
│      size_t* out_body_n                  // 响应体长度                  │
│  );                                                                     │
│                                                                         │
│  调用时机：                                                             │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  1. 对端发送 primary 消息 (stream, function)                     │   │
│  │  2. protocol::Session 的 run loop 接收消息                       │   │
│  │  3. 查找 router 中注册的 (stream, function) handler              │   │
│  │  4. 在 io 线程调用 handler                                       │   │
│  │  5. 若 request.w_bit==1 且 handler 返回 OK：                     │   │
│  │     └── 库自动发送 secondary (stream, function+1, out_body)      │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  重要约定：                                                             │
│  ├── out_body 必须用 secs_malloc() 分配                                 │
│  ├── 库会在复制后调用 secs_free() 释放                                  │
│  └── 回调在 io 线程执行，禁止调用阻塞式 API                             │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 10.3 SML 自动回包

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    SML Default Handler                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  secs_protocol_session_set_sml_default_handler(sess, rt)                │
│                                                                         │
│  工作流程：                                                             │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  1. 收到 primary 消息 (S, F, W=1, body)                          │   │
│  │  2. 解码 body → secs::ii::Item                                   │   │
│  │  3. 调用 runtime->match_response(S, F, item)                     │   │
│  │     └── 返回匹配的响应消息名（如 "S1F2"）                        │   │
│  │  4. 获取响应模板 runtime->get_message(name)                      │   │
│  │  5. 验证模板 (S', F', W')：                                      │   │
│  │     ├── S' == S                                                  │   │
│  │     ├── F' == F + 1                                              │   │
│  │     └── W' == false                                              │   │
│  │  6. 编码响应模板 → bytes                                         │   │
│  │  7. 返回 HandlerResult{ok, bytes} → 库自动发送 secondary         │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  注意：函数内部拷贝 rt，调用后 rt 可销毁                                │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 11. 模块依赖关系

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    C_API 模块依赖关系                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  外部依赖：                                                             │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  asio (standalone)                                               │   │
│  │  ├── asio::io_context         (secs_context 核心)                │   │
│  │  ├── asio::co_spawn           (协程启动)                         │   │
│  │  ├── asio::post               (跨线程投递)                       │   │
│  │  ├── asio::executor_work_guard (保持 io 线程运行)                │   │
│  │  └── asio::ip::tcp            (TCP 连接)                         │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  标准库依赖：                                                           │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  <thread>            (io_thread)                                 │   │
│  │  <mutex>             (run_blocking 同步)                         │   │
│  │  <condition_variable>(run_blocking 同步)                         │   │
│  │  <future>            (io_thread_id 初始化同步)                   │   │
│  │  <memory>            (shared_ptr/unique_ptr)                     │   │
│  │  <cstdlib>           (malloc/free)                               │   │
│  │  <cstring>           (memcpy/strcmp)                             │   │
│  │  <system_error>      (error_code/error_category)                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  本库依赖：                                                             │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  secs::core                                                      │   │
│  │  ├── byte, bytes_view, mutable_bytes_view                        │   │
│  │  ├── errc, make_error_code, error_category()                     │   │
│  │  ├── Event                                                       │   │
│  │  └── LogLevel, set_log_level                                     │   │
│  │                                                                  │   │
│  │  secs::ii                                                        │   │
│  │  ├── Item, List, ASCII, Binary, Boolean                          │   │
│  │  ├── I1~I8, U1~U8, F4, F8                                        │   │
│  │  ├── encode(), decode_one()                                      │   │
│  │  ├── DecodeLimits                                                │   │
│  │  └── error_category()                                            │   │
│  │                                                                  │   │
│  │  secs::sml                                                       │   │
│  │  ├── Runtime                                                     │   │
│  │  ├── lexer_error_category(), parser_error_category()             │   │
│  │  └── match_response(), get_message()                             │   │
│  │                                                                  │   │
│  │  secs::hsms                                                      │   │
│  │  ├── Connection, Stream                                          │   │
│  │  ├── Session, SessionOptions                                     │   │
│  │  ├── Message, Header                                             │   │
│  │  └── make_data_message()                                         │   │
│  │                                                                  │   │
│  │  secs::secs1                                                     │   │
│  │  └── error_category()                                            │   │
│  │                                                                  │   │
│  │  secs::protocol                                                  │   │
│  │  ├── Session, SessionOptions                                     │   │
│  │  ├── Router                                                      │   │
│  │  ├── DataMessage, HandlerResult                                  │   │
│  │  └── async_run(), async_send(), async_request()                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 12. API 分类汇总

### 12.1 基础设施

| API | 功能 | 线程安全 |
|-----|------|----------|
| `secs_malloc(n)` | 分配 n 字节内存 | 是 |
| `secs_free(p)` | 释放内存 | 是 |
| `secs_error_is_ok(err)` | 判断错误码是否成功 | 是 |
| `secs_error_message(err)` | 获取错误描述字符串 | 是 |
| `secs_version_string()` | 获取库版本 | 是 |
| `secs_log_set_level(level)` | 设置日志级别 | 是 |

### 12.2 上下文

| API | 功能 | 阻塞 |
|-----|------|------|
| `secs_context_create(&ctx)` | 创建上下文（启动 io 线程） | 是 |
| `secs_context_destroy(ctx)` | 销毁上下文（等待 io 线程退出） | 是 |

### 12.3 SECS-II Item

| API | 功能 |
|-----|------|
| `secs_ii_item_create_list(&item)` | 创建空 List |
| `secs_ii_item_create_ascii(s, n, &item)` | 创建 ASCII 字符串 |
| `secs_ii_item_create_binary(b, n, &item)` | 创建 Binary 数组 |
| `secs_ii_item_create_boolean(v, n, &item)` | 创建 Boolean 数组 |
| `secs_ii_item_create_i1~i8(v, n, &item)` | 创建有符号整数数组 |
| `secs_ii_item_create_u1~u8(v, n, &item)` | 创建无符号整数数组 |
| `secs_ii_item_create_f4/f8(v, n, &item)` | 创建浮点数组 |
| `secs_ii_item_destroy(item)` | 销毁 Item |
| `secs_ii_item_get_type(item, &type)` | 获取类型 |
| `secs_ii_item_list_size/get/append` | List 操作 |
| `secs_ii_item_*_view(item, &ptr, &n)` | 获取数据视图 |
| `secs_ii_item_boolean_copy(item, &v, &n)` | 拷贝 Boolean 数据 |
| `secs_ii_encode(item, &bytes, &n)` | 编码为字节流 |
| `secs_ii_decode_one(bytes, n, &consumed, &item)` | 解码单个 Item |
| `secs_ii_decode_one_with_limits(...)` | 带资源限制解码 |

### 12.4 SML Runtime

| API | 功能 |
|-----|------|
| `secs_sml_runtime_create(&rt)` | 创建 Runtime |
| `secs_sml_runtime_destroy(rt)` | 销毁 Runtime |
| `secs_sml_runtime_load(rt, src, n)` | 加载 SML 脚本 |
| `secs_sml_runtime_match_response(...)` | 匹配条件响应 |
| `secs_sml_runtime_get_message_body_by_name(...)` | 获取消息模板 |

### 12.5 HSMS

| API | 功能 | 阻塞 |
|-----|------|------|
| `secs_hsms_connection_create_memory_duplex(...)` | 创建内存连接对 | 否 |
| `secs_hsms_connection_destroy(c)` | 销毁连接 | 否 |
| `secs_hsms_session_create[_v2](...)` | 创建会话 | 否 |
| `secs_hsms_session_destroy(sess)` | 销毁会话 | 是 |
| `secs_hsms_session_open_active_ip(...)` | 主动连接 | 是 |
| `secs_hsms_session_open_passive_ip(...)` | 被动监听 | 是 |
| `secs_hsms_session_open_*_connection(...)` | 注入连接 | 是 |
| `secs_hsms_session_is_selected(...)` | 查询选择状态 | 是 |
| `secs_hsms_session_stop(sess)` | 停止会话 | 否 |
| `secs_hsms_session_linktest(sess)` | 发送 LINKTEST | 是 |
| `secs_hsms_session_send_data_*(...)` | 发送数据消息 | 是 |
| `secs_hsms_session_receive_data(...)` | 接收数据消息 | 是 |
| `secs_hsms_session_request_data(...)` | 请求-响应 | 是 |

### 12.6 Protocol

| API | 功能 | 阻塞 |
|-----|------|------|
| `secs_protocol_session_create_from_hsms(...)` | 从 HSMS 创建 | 否 |
| `secs_protocol_session_destroy(sess)` | 销毁会话 | 是 |
| `secs_protocol_session_stop(sess)` | 停止会话 | 否 |
| `secs_protocol_session_set_handler(...)` | 注册 handler | 否 |
| `secs_protocol_session_set_default_handler(...)` | 注册默认 handler | 否 |
| `secs_protocol_session_set_sml_default_handler(...)` | SML 自动回包 | 否 |
| `secs_protocol_session_clear_default_handler(...)` | 清除默认 handler | 否 |
| `secs_protocol_session_erase_handler(...)` | 移除 handler | 否 |
| `secs_protocol_session_send(...)` | 发送消息 | 是 |
| `secs_protocol_session_request(...)` | 请求-响应 | 是 |

---

## 13. 源文件清单

| 文件 | 行数 | 说明 |
|------|------|------|
| `include/secs/c_api.h` | ~544 | C 语言头文件（接口声明） |
| `src/c_api.cpp` | ~2115 | C API 实现 |

---

## 14. 使用示例

### 14.1 基本 SECS-II 编解码

```c
#include <secs/c_api.h>
#include <stdio.h>

int main() {
    // 创建 List: L[A"hello", U2[1, 2, 3]]
    secs_ii_item_t *list, *ascii, *u2;
    secs_ii_item_create_list(&list);
    secs_ii_item_create_ascii("hello", 5, &ascii);

    uint16_t vals[] = {1, 2, 3};
    secs_ii_item_create_u2(vals, 3, &u2);

    secs_ii_item_list_append(list, ascii);
    secs_ii_item_list_append(list, u2);

    // 编码
    uint8_t *bytes; size_t n;
    secs_ii_encode(list, &bytes, &n);

    // 解码
    secs_ii_item_t *decoded; size_t consumed;
    secs_ii_decode_one(bytes, n, &consumed, &decoded);

    // 清理
    secs_free(bytes);
    secs_ii_item_destroy(decoded);
    secs_ii_item_destroy(u2);
    secs_ii_item_destroy(ascii);
    secs_ii_item_destroy(list);
    return 0;
}
```

### 14.2 HSMS 通信

```c
#include <secs/c_api.h>

int main() {
    secs_context_t *ctx;
    secs_context_create(&ctx);

    // 创建会话
    secs_hsms_session_options_t opts = {
        .session_id = 0,
        .t3_ms = 45000,
        .t5_ms = 10000,
        .t6_ms = 5000,
        .t7_ms = 10000,
        .t8_ms = 5000,
    };
    secs_hsms_session_t *sess;
    secs_hsms_session_create(ctx, &opts, &sess);

    // 连接
    secs_error_t err = secs_hsms_session_open_active_ip(sess, "192.168.1.100", 5000);
    if (!secs_error_is_ok(err)) {
        char *msg = secs_error_message(err);
        printf("连接失败: %s\n", msg);
        secs_free(msg);
    }

    // 发送请求
    uint8_t body[] = { /* SECS-II 编码数据 */ };
    secs_hsms_data_message_t reply;
    secs_hsms_session_request_data(sess, 1, 1, body, sizeof(body), 0, &reply);

    // 处理响应
    // ...

    secs_hsms_data_message_free(&reply);
    secs_hsms_session_destroy(sess);
    secs_context_destroy(ctx);
    return 0;
}
```
