# SML 模块详细实现原理

> 文档更新日期：2026-01-09（Codex）  
> 基于源码版本：当前 main 分支  
> 说明：本文覆盖当前实现的 SML 子集 + SMLX v0（占位符/渲染/主动发送）；扩展背景与提案见 `docs/architecture/09-smlx-extension.md`。

## 1. 模块概述

`secs::sml` 模块实现 SML（SECS Message Language）解析器与运行时，提供：

- **词法分析**：`Lexer` 将 SML 源文本转换为 Token 序列
- **语法分析**：`Parser` 将 Token 序列转换为 AST (Document)
- **运行时**：`Runtime` 提供消息模板查找与条件响应匹配
- **模板渲染（SMLX v0）**：`RenderContext` + `render_item()` 将“可包含占位符的模板”渲染为 `secs::ii::Item`
- **主动发送（SMLX v0）**：`Runtime::encode_message_body()` 输出可直接发送的 SECS-II body bytes（并返回 stream/function/w_bit）

```
┌─────────────────────────────────────────────────────────────────────┐
│                        secs::sml 模块                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                    SML 源文本                                │   │
│  │  name: S1F1 W <L <A "hello">>.                              │   │
│  │  if (S1F1(2)==<A "hello">) reply.                           │   │
│  │  every 10 send heartbeat.                                   │   │
│  └───────────────────────────┬─────────────────────────────────┘   │
│                              │                                      │
│                              ▼                                      │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                    Lexer（词法分析）                         │   │
│  │  Token: Identifier, String, Integer, KwL, KwA, ...          │   │
│  └───────────────────────────┬─────────────────────────────────┘   │
│                              │                                      │
│                              ▼                                      │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                    Parser（语法分析）                        │   │
│  │  AST: Document { messages, conditions, timers }             │   │
│  └───────────────────────────┬─────────────────────────────────┘   │
│                              │                                      │
│                              ▼                                      │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                    Runtime（运行时）                         │   │
│  │  - 消息模板查找 (O(1))                                      │   │
│  │  - 条件响应匹配                                              │   │
│  │  - 定时规则访问                                              │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 2. SML 语法规范

### 2.1 消息定义语法

```
┌─────────────────────────────────────────────────────────────────────┐
│                    SML 消息定义语法                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  基本格式：                                                         │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  [name:] SxFy [W] [<Item>].                                 │    │
│  │                                                             │    │
│  │  - name    : 可选的消息名称                                 │    │
│  │  - SxFy    : Stream/Function (如 S1F1, S2F33)               │    │
│  │  - W       : 可选的等待位标记                               │    │
│  │  - <Item>  : 可选的 SECS-II 数据项                          │    │
│  │  - .       : 语句结束符                                     │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  示例：                                                             │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  // 命名消息，带 W 位和消息体                               │    │
│  │  establish: S1F13 W <L                                      │    │
│  │    <A "">                                                   │    │
│  │    <A "1.0.0">                                              │    │
│  │  >.                                                         │    │
│  │                                                             │    │
│  │  // 匿名消息（直接用 SxFy 标识）                            │    │
│  │  S1F14 <L                                                   │    │
│  │    <U2 0>                                                   │    │
│  │    <L                                                       │    │
│  │      <A "EQUIP">                                            │    │
│  │      <A "2.0.0">                                            │    │
│  │    >                                                        │    │
│  │  >.                                                         │    │
│  │                                                             │    │
│  │  // 无消息体的简单消息                                      │    │
│  │  S1F1 W.                                                    │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

说明（SMLX v0）：

- 消息体 `<Item>` 支持“值占位符”：在原本写字面量的位置写 **标识符（Identifier）**，例如 `<A MDLN>`、`<U2 1 SVIDS 3>`、`<B BYTES>`。
- 占位符的值由宿主程序通过 `secs::sml::RenderContext` 注入，并在发送前渲染（见 `include/secs/sml/render.hpp` 与 `include/secs/sml/runtime.hpp`）。
- `if (...) ==<Item>` 的期望值 **当前不允许占位符**（解析阶段直接报 `sml.parser/invalid_condition`，见 `tests/test_sml_parser.cpp`）。

### 2.2 SECS-II 数据项语法

```
┌─────────────────────────────────────────────────────────────────────┐
│                    SECS-II Item 语法                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  通用格式：<TYPE [values...]>                                       │
│                                                                     │
│  支持的类型：                                                       │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  类型      语法示例                     说明                │    │
│  │  ─────────────────────────────────────────────────────────  │    │
│  │  L         <L <子项1> <子项2> ...>      列表（可嵌套）      │    │
│  │  A         <A "string">                 ASCII 字符串        │    │
│  │  B         <B 0x01 0x02 255>            二进制数组          │    │
│  │  Boolean   <Boolean 0 1 1>              布尔数组            │    │
│  │  U1        <U1 1 2 255>                 uint8 数组          │    │
│  │  U2        <U2 1000 65535>              uint16 数组         │    │
│  │  U4        <U4 100000>                  uint32 数组         │    │
│  │  U8        <U8 123456789012>            uint64 数组         │    │
│  │  I1        <I1 -128 0 127>              int8 数组           │    │
│  │  I2        <I2 -32768 32767>            int16 数组          │    │
│  │  I4        <I4 -2147483648>             int32 数组          │    │
│  │  I8        <I8 -9223372036854775808>    int64 数组          │    │
│  │  F4        <F4 1.5 -0.001>              float 数组          │    │
│  │  F8        <F8 3.14159265359>           double 数组         │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  数值字面量支持：                                                   │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  - 十进制：123, -456                                        │    │
│  │  - 十六进制：0x1F, 0xFF                                     │    │
│  │  - 浮点数：1.5, -0.001, 1e-10                               │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

说明（SMLX v0）：

- `A`：除 `<A "string">` 外，也支持 `<A IDENT>`（IDENT 作为占位符，运行时要求变量值为 `ASCII`）。
- `B/Boolean/U*/I*/F*`：数组的 values 列表支持混写字面量与占位符（IDENT 作为占位符，运行时要求变量值类型与目标类型一致，并按 values 拼接展开）。
- `L`：List 仍是“子 Item 序列”，当前不支持在 List 内直接插入“占位符子树”（只能在子 Item 的值位置用占位符）。

### 2.3 条件规则语法

```
┌─────────────────────────────────────────────────────────────────────┐
│                    条件规则语法                                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  格式：if (条件) 响应消息名.                                        │
│                                                                     │
│  条件格式：消息名[(索引)][==<期望值>]                               │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  - 消息名  : 触发消息的名称或 SxFy                          │    │
│  │  - (索引)  : 可选，指定消息体中的元素位置（1-based 先序）    │    │
│  │  - ==<值>  : 可选，指定期望的元素值                         │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  示例：                                                             │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  // 收到 S1F1 时，回复 reply 消息                           │    │
│  │  if (S1F1) reply.                                           │    │
│  │                                                             │    │
│  │  // 收到 S2F21，且第 2 个元素等于 <U1 1> 时，回复 ack       │    │
│  │  if (S2F21(2)==<U1 1>) ack.                                 │    │
│  │                                                             │    │
│  │  // 使用消息名引用（需要先定义 request 消息）               │    │
│  │  if (request(3)==<A "START">) start_response.               │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  索引说明（先序遍历编号）：                                         │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  消息体：<L <A "a"> <L <U1 1> <U1 2>>>                      │    │
│  │                                                             │    │
│  │  先序遍历编号：                                             │    │
│  │    1: <L ...>          (根节点)                             │    │
│  │    2: <A "a">          (第一个子元素)                       │    │
│  │    3: <L ...>          (第二个子元素，嵌套 List)            │    │
│  │    4: <U1 1>           (嵌套 List 的第一个子元素)           │    │
│  │    5: <U1 2>           (嵌套 List 的第二个子元素)           │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

说明（当前实现）：

- 条件期望值 `==<...>` 仅允许纯字面量；若 `<...>` 内包含占位符（Identifier），解析将失败并返回 `sml.parser/invalid_condition`。

### 2.4 定时规则语法

```
┌─────────────────────────────────────────────────────────────────────┐
│                    定时规则语法                                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  格式：every N send 消息名.                                         │
│                                                                     │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  - N       : 间隔秒数（正整数）                             │    │
│  │  - 消息名  : 要定时发送的消息名称                           │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  示例：                                                             │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  // 每 10 秒发送 heartbeat 消息                             │    │
│  │  every 10 send heartbeat.                                   │    │
│  │                                                             │    │
│  │  // 每 60 秒发送状态查询                                    │    │
│  │  every 60 send status_query.                                │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 3. Token 类型定义

```
┌─────────────────────────────────────────────────────────────────────┐
│                    TokenType 枚举                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  字面量：                                                           │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  Identifier  : 标识符（name, S1F1, StatusTank1）            │    │
│  │  String      : 字符串字面量（"..." 或 '...'）               │    │
│  │  Integer     : 整数字面量（123, 0x1F, -456）                │    │
│  │  Float       : 浮点数字面量（0.5567, 1e-10）                │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  关键字：                                                           │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  KwIf      : "if"                                           │    │
│  │  KwEvery   : "every"                                        │    │
│  │  KwSend    : "send"                                         │    │
│  │  KwW       : "W"                                            │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  数据项类型关键字：                                                 │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  KwL       : "L"         KwA       : "A"                    │    │
│  │  KwB       : "B"         KwBoolean : "Boolean"              │    │
│  │  KwU1-KwU8 : "U1"-"U8"   KwI1-KwI8 : "I1"-"I8"              │    │
│  │  KwF4      : "F4"        KwF8      : "F8"                   │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  标点符号：                                                         │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  Colon    : ':'    Dot      : '.'    LAngle   : '<'         │    │
│  │  RAngle   : '>'    LParen   : '('    RParen   : ')'         │    │
│  │  LBracket : '['    RBracket : ']'    Equals   : '=='        │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  特殊：                                                             │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  Eof   : 文件结束                                           │    │
│  │  Error : 词法错误                                           │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 4. Lexer 词法分析器

### 4.1 扫描流程

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Lexer::tokenize() 流程                           │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  while (!at_end()) {                                        │    │
│  │      skip_whitespace();  // 跳过空白字符                    │    │
│  │      if (at_end()) break;                                   │    │
│  │                                                             │    │
│  │      if (skip_comment(result)) {  // 跳过注释               │    │
│  │          if (result.ec) return result;  // 未闭合块注释     │    │
│  │          continue;                                          │    │
│  │      }                                                      │    │
│  │                                                             │    │
│  │      token_start_ = current_;                               │    │
│  │      Token token = scan_token();                            │    │
│  │                                                             │    │
│  │      if (token.type == Error) {                             │    │
│  │          result.ec = make_error_code(last_error_kind_);     │    │
│  │          result.error_line = token.line;                    │    │
│  │          result.error_message = token.value;                │    │
│  │          return result;                                     │    │
│  │      }                                                      │    │
│  │                                                             │    │
│  │      result.tokens.push_back(token);                        │    │
│  │  }                                                          │    │
│  │                                                             │    │
│  │  result.tokens.push_back(make_token(Eof));                  │    │
│  │  return result;                                             │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 4.2 Token 扫描分支

```
┌─────────────────────────────────────────────────────────────────────┐
│                    scan_token() 分支                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  char c = advance();                                        │    │
│  │                                                             │    │
│  │  switch (c) {                                               │    │
│  │      // 单字符标点                                          │    │
│  │      case ':': return Colon;                                │    │
│  │      case '.': return Dot;                                  │    │
│  │      case '<': return LAngle;                               │    │
│  │      case '>': return RAngle;                               │    │
│  │      case '(': return LParen;                               │    │
│  │      case ')': return RParen;                               │    │
│  │      case '[': return LBracket;                             │    │
│  │      case ']': return RBracket;                             │    │
│  │                                                             │    │
│  │      // 双字符标点                                          │    │
│  │      case '=':                                              │    │
│  │          if (peek() == '=') { advance(); return Equals; }   │    │
│  │          else return Error;                                 │    │
│  │                                                             │    │
│  │      // 字符串                                              │    │
│  │      case '"': case '\'':                                   │    │
│  │          return scan_string(c);                             │    │
│  │                                                             │    │
│  │      default:                                               │    │
│  │          // 标识符或关键字                                  │    │
│  │          if (isalpha(c) || c == '_')                        │    │
│  │              return scan_identifier();                      │    │
│  │                                                             │    │
│  │          // 数字                                            │    │
│  │          if (isdigit(c) || c == '-' && isdigit(peek()))     │    │
│  │              return scan_number();                          │    │
│  │                                                             │    │
│  │          return Error;                                      │    │
│  │  }                                                          │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 4.3 注释处理

```
┌─────────────────────────────────────────────────────────────────────┐
│                    注释处理                                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  行注释：                                                           │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  // 这是行注释，持续到行尾                                  │    │
│  │  if (peek() == '/' && peek_next() == '/') {                 │    │
│  │      while (!at_end() && peek() != '\n') advance();         │    │
│  │      return true;                                           │    │
│  │  }                                                          │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  块注释：                                                           │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  /* 这是块注释                                              │    │
│  │     可以跨多行 */                                           │    │
│  │  if (peek() == '/' && peek_next() == '*') {                 │    │
│  │      advance(); advance();  // 跳过 /*                      │    │
│  │      while (!at_end()) {                                    │    │
│  │          if (peek() == '*' && peek_next() == '/') {         │    │
│  │              advance(); advance();  // 跳过 */              │    │
│  │              return true;                                   │    │
│  │          }                                                  │    │
│  │          advance();                                         │    │
│  │      }                                                      │    │
│  │      // 未闭合：报错                                        │    │
│  │      result.ec = unterminated_comment;                      │    │
│  │      return true;                                           │    │
│  │  }                                                          │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 4.4 数字扫描

```
┌─────────────────────────────────────────────────────────────────────┐
│                    scan_number() 流程                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  1. 可选的负号：                                            │    │
│  │     if (peek() == '-') advance();                           │    │
│  │                                                             │    │
│  │  2. 十六进制判断：                                          │    │
│  │     if (peek() == '0' && (peek_next() == 'x' || 'X')) {     │    │
│  │         advance(); advance();  // 跳过 0x                   │    │
│  │         while (isxdigit(peek())) advance();                 │    │
│  │         return Integer;                                     │    │
│  │     }                                                       │    │
│  │                                                             │    │
│  │  3. 十进制整数部分：                                        │    │
│  │     while (isdigit(peek())) advance();                      │    │
│  │                                                             │    │
│  │  4. 浮点数判断（要求 '.' 后有数字）：                       │    │
│  │     if (peek() == '.' && isdigit(peek_next())) {            │    │
│  │         advance();  // 小数点                               │    │
│  │         while (isdigit(peek())) advance();                  │    │
│  │                                                             │    │
│  │         // 可选的指数部分                                   │    │
│  │         if (peek() == 'e' || peek() == 'E') {               │    │
│  │             advance();                                      │    │
│  │             if (peek() == '+' || '-') advance();            │    │
│  │             while (isdigit(peek())) advance();              │    │
│  │         }                                                   │    │
│  │         return Float;                                       │    │
│  │     }                                                       │    │
│  │                                                             │    │
│  │  5. 否则为整数：                                            │    │
│  │     return Integer;                                         │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 5. Parser 语法分析器

### 5.1 递归下降解析

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Parser 解析架构                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  parse() 主循环：                                                   │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  while (!at_end() && !had_error_) {                         │    │
│  │      parse_statement();                                     │    │
│  │  }                                                          │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  parse_statement() 分支：                                           │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  if (match(KwIf)) {                                         │    │
│  │      return parse_if_rule();       // 条件规则              │    │
│  │  }                                                          │    │
│  │  if (match(KwEvery)) {                                      │    │
│  │      return parse_every_rule();    // 定时规则              │    │
│  │  }                                                          │    │
│  │  return parse_message_def();       // 消息定义              │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  解析调用图：                                                       │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  parse()                                                    │    │
│  │    └── parse_statement()                                    │    │
│  │          ├── parse_if_rule()                                │    │
│  │          │     └── parse_condition()                        │    │
│  │          │           └── parse_item()                       │    │
│  │          ├── parse_every_rule()                             │    │
│  │          └── parse_message_def()                            │    │
│  │                └── parse_item()                             │    │
│  │                      ├── parse_list()                       │    │
│  │                      │     └── parse_item() (递归)          │    │
│  │                      ├── parse_ascii()                      │    │
│  │                      ├── parse_binary()                     │    │
│  │                      ├── parse_boolean()                    │    │
│  │                      ├── parse_unsigned()                   │    │
│  │                      ├── parse_signed()                     │    │
│  │                      └── parse_float()                      │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 5.2 消息定义解析

```
┌─────────────────────────────────────────────────────────────────────┐
│                    parse_message_def() 流程                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  支持的格式：                                                       │
│  - 命名消息：name: SxFy [W] <Item>.                                │
│  - 匿名消息：SxFy [W] <Item>.                                       │
│                                                                     │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  1. 读取第一个 token：                                      │    │
│  │     if (!Identifier && !LAngle) error();                    │    │
│  │     first_token = advance().value;                          │    │
│  │                                                             │    │
│  │  2. 检查是否为命名消息（有冒号）：                          │    │
│  │     if (match(Colon)) {                                     │    │
│  │         msg.name = first_token;                             │    │
│  │         first_token = advance().value;  // 获取 SxFy        │    │
│  │     }                                                       │    │
│  │                                                             │    │
│  │  3. 解析 SxFy：                                             │    │
│  │     if (!parse_sf_string(first_token, stream, function))    │    │
│  │         error("invalid stream/function");                   │    │
│  │                                                             │    │
│  │  4. 可选的 W 位：                                           │    │
│  │     if (match(KwW)) msg.w_bit = true;                       │    │
│  │                                                             │    │
│  │  5. 可选的 Item：                                           │    │
│  │     if (check(LAngle)) {                                    │    │
│  │         msg.item = parse_item();                            │    │
│  │     }                                                       │    │
│  │                                                             │    │
│  │  6. 结束符：                                                │    │
│  │     if (!match(Dot)) error("expected '.'");                 │    │
│  │                                                             │    │
│  │  7. 添加到文档：                                            │    │
│  │     document_.messages.push_back(msg);                      │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 5.3 SxFy 格式解析

```
┌─────────────────────────────────────────────────────────────────────┐
│                    parse_sf_string() 函数                           │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  输入格式：S1F1, s15f32, 'S1F1'                                     │
│                                                                     │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  bool parse_sf_string(string_view text,                     │    │
│  │                       uint8_t& stream,                      │    │
│  │                       uint8_t& function) {                  │    │
│  │                                                             │    │
│  │      // 去除可能的引号                                      │    │
│  │      if (text.front() == '\'' && text.back() == '\'')       │    │
│  │          text = text.substr(1, text.size() - 2);            │    │
│  │                                                             │    │
│  │      // 检查 'S' 或 's' 开头                                │    │
│  │      if (text[0] != 'S' && text[0] != 's') return false;    │    │
│  │                                                             │    │
│  │      // 查找 'F' 或 'f' 位置                                │    │
│  │      auto f_pos = text.find_first_of("Ff");                 │    │
│  │      if (f_pos == npos || f_pos < 2) return false;          │    │
│  │                                                             │    │
│  │      // 解析 stream 和 function                             │    │
│  │      string_view stream_str = text.substr(1, f_pos - 1);    │    │
│  │      string_view func_str = text.substr(f_pos + 1);         │    │
│  │                                                             │    │
│  │      int s, f;                                              │    │
│  │      from_chars(stream_str, s);                             │    │
│  │      from_chars(func_str, f);                               │    │
│  │                                                             │    │
│  │      // 校验范围                                            │    │
│  │      if (s < 0 || s > 127 || f < 0 || f > 255)              │    │
│  │          return false;                                      │    │
│  │                                                             │    │
│  │      stream = s; function = f;                              │    │
│  │      return true;                                           │    │
│  │  }                                                          │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 5.4 Item 解析

说明（SMLX v0）：

- `Parser::parse_item()` 的返回类型为 **TemplateItem**（模板 AST），而不是 `secs::ii::Item`。
- 在 `A/B/Boolean/U*/I*/F*` 的 values 位置，`Identifier` token 会被解析为占位符 `VarRef{name}`。
- 条件期望值 `==<...>` 在解析阶段会检查并拒绝占位符（见 `src/sml/parser.cpp` 的 `item_has_var(...)` 分支）。

```
┌─────────────────────────────────────────────────────────────────────┐
│                    parse_item() 流程                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  1. 匹配开始符号：                                          │    │
│  │     if (!match(LAngle)) error("expected '<'");              │    │
│  │                                                             │    │
│  │  2. 根据类型关键字分派：                                    │    │
│  │     switch (peek().type) {                                  │    │
│  │         case KwL:       return parse_list();                │    │
│  │         case KwA:       return parse_ascii();               │    │
│  │         case KwB:       return parse_binary();              │    │
│  │         case KwBoolean: return parse_boolean();             │    │
│  │         case KwU1..U8:  return parse_unsigned(type);        │    │
│  │         case KwI1..I8:  return parse_signed(type);          │    │
│  │         case KwF4..F8:  return parse_float(type);           │    │
│  │         default:        error("expected item type");        │    │
│  │     }                                                       │    │
│  │                                                             │    │
│  │  3. 匹配结束符号：                                          │    │
│  │     if (!match(RAngle)) error("expected '>'");              │    │
│  │                                                             │    │
│  │  4. 返回解析结果。                                          │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  parse_list() - 解析列表：                                          │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  advance();  // 跳过 'L'                                    │    │
│  │                                                             │    │
│  │  // 可选的 [n] 大小提示（跳过）                             │    │
│  │  if (match(LBracket)) {                                     │    │
│  │      while (!check(RBracket) && !at_end()) advance();       │    │
│  │      match(RBracket);                                       │    │
│  │  }                                                          │    │
│  │                                                             │    │
│  │  // 递归解析子元素                                          │    │
│  │  vector<TemplateItem> items;                                │    │
│  │  while (check(LAngle)) {                                    │    │
│  │      items.push_back(parse_item());                         │    │
│  │  }                                                          │    │
│  │                                                             │    │
│  │  return TemplateItem(items);                                │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 6. AST 数据结构

### 6.1 Document 结构

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Document AST 结构                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  struct Document {                                                  │
│      vector<MessageDef> messages;       // 消息定义列表             │
│      vector<ConditionRule> conditions;  // 条件规则列表             │
│      vector<TimerRule> timers;          // 定时规则列表             │
│  };                                                                 │
│                                                                     │
│  struct MessageDef {                                                │
│      string name;           // 消息名称（可为空=匿名）              │
│      uint8_t stream;        // Stream 号                            │
│      uint8_t function;      // Function 号                          │
│      bool w_bit;            // W 位                                 │
│      TemplateItem item;     // 消息体模板（可包含占位符）            │
│  };                                                                 │
│                                                                     │
│  struct ConditionRule {                                             │
│      Condition condition;   // 触发条件                             │
│      string response_name;  // 响应消息名                           │
│  };                                                                 │
│                                                                     │
│  struct Condition {                                                 │
│      string message_name;            // 触发消息名或 SxFy           │
│      optional<size_t> index;         // 可选的元素索引              │
│      optional<TemplateItem> expected;// 可选的期望值（仅字面量）     │
│  };                                                                 │
│                                                                     │
│  struct TimerRule {                                                 │
│      uint32_t interval_seconds;      // 间隔秒数                    │
│      string message_name;            // 消息名                      │
│  };                                                                 │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

补充说明：

- `TemplateItem` / `VarRef` 等模板类型定义见 `include/secs/sml/ast.hpp`；渲染逻辑见 `include/secs/sml/render.hpp` 与 `src/sml/render.cpp`。
- `MessageDef.item` 与 `Condition.expected` 共享同一份模板表示；但 `parse_sml()` 会保证 `Condition.expected` 不含占位符（保持条件匹配的确定性）。

### 6.2 AST 示例

```
┌─────────────────────────────────────────────────────────────────────┐
│                    AST 构建示例                                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  SML 源码：                                                         │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  req: S1F1 W <L <A "hello">>.                               │    │
│  │  rsp: S1F2 <L <U2 0> <A "world">>.                          │    │
│  │  if (S1F1) rsp.                                             │    │
│  │  every 10 send req.                                         │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  生成的 Document：                                                  │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  Document {                                                 │    │
│  │      messages: [                                            │    │
│  │          MessageDef {                                       │    │
│  │              name: "req",                                   │    │
│  │              stream: 1, function: 1, w_bit: true,           │    │
│  │              item: List[ASCII("hello")]                     │    │
│  │          },                                                 │    │
│  │          MessageDef {                                       │    │
│  │              name: "rsp",                                   │    │
│  │              stream: 1, function: 2, w_bit: false,          │    │
│  │              item: List[U2(0), ASCII("world")]              │    │
│  │          }                                                  │    │
│  │      ],                                                     │    │
│  │      conditions: [                                          │    │
│  │          ConditionRule {                                    │    │
│  │              condition: { message_name: "S1F1" },           │    │
│  │              response_name: "rsp"                           │    │
│  │          }                                                  │    │
│  │      ],                                                     │    │
│  │      timers: [                                              │    │
│  │          TimerRule {                                        │    │
│  │              interval_seconds: 10,                          │    │
│  │              message_name: "req"                            │    │
│  │          }                                                  │    │
│  │      ]                                                      │    │
│  │  }                                                          │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 7. Runtime 运行时

### 7.1 索引构建

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Runtime 索引结构                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  两个索引实现 O(1) 消息查找：                                       │
│                                                                     │
│  1. name_index_：消息名 -> 消息下标                                 │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  unordered_map<string, size_t, TransparentHash> name_index_;│    │
│  │                                                             │    │
│  │  // 支持 string_view 透明查找，避免临时 string 分配         │    │
│  │  struct TransparentStringHash {                             │    │
│  │      using is_transparent = void;                           │    │
│  │      size_t operator()(string_view sv) const noexcept;      │    │
│  │  };                                                         │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  2. sf_index_：(Stream, Function) -> 消息下标                       │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  unordered_map<uint16_t, size_t> sf_index_;                 │    │
│  │                                                             │    │
│  │  // Key = (stream << 8) | function                          │    │
│  │  // 选择规则：匿名消息优先；否则首个命名匹配               │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  build_index() 流程：                                               │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  for (i = 0; i < messages.size(); ++i) {                    │    │
│  │      const auto& msg = messages[i];                         │    │
│  │                                                             │    │
│  │      // 命名消息：加入 name_index_                          │    │
│  │      if (!msg.name.empty()) {                               │    │
│  │          name_index_[msg.name] = i;                         │    │
│  │      }                                                      │    │
│  │                                                             │    │
│  │      // Stream/Function 索引：                              │    │
│  │      uint16_t key = (stream << 8) | function;               │    │
│  │      if (msg.name.empty()) {                                │    │
│  │          sf_index_[key] = i;        // 匿名消息始终占优       │    │
│  │      } else if (sf_index_.find(key) == end) {               │    │
│  │          sf_index_[key] = i;        // 首个命名匹配           │    │
│  │      }                                                      │    │
│  │  }                                                          │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 7.2 消息查找

```
┌─────────────────────────────────────────────────────────────────────┐
│                    get_message() 查找流程                           │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  get_message(name)：按名称查找                                      │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  1. 尝试 name_index_ 精确匹配：                             │    │
│  │     auto it = name_index_.find(name);                       │    │
│  │     if (it != end) return &messages[it->second];            │    │
│  │                                                             │    │
│  │  2. 尝试解析为 SxFy 格式：                                  │    │
│  │     uint8_t stream, function;                               │    │
│  │     if (parse_sf(name, stream, function)) {                 │    │
│  │         return get_message(stream, function);               │    │
│  │     }                                                       │    │
│  │                                                             │    │
│  │  3. 未找到：                                                │    │
│  │     return nullptr;                                         │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  get_message(stream, function)：按 S/F 查找                         │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  1. 查找 sf_index_：                                       │    │
│  │     uint16_t key = (stream << 8) | function;                │    │
│  │     auto it = sf_index_.find(key);                          │    │
│  │     if (it != end) return &messages[it->second];            │    │
│  │                                                             │    │
│  │  2. 未找到：                                                │    │
│  │     return nullptr;                                         │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 7.3 条件响应匹配

```
┌─────────────────────────────────────────────────────────────────────┐
│                    match_response() 匹配流程                        │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  optional<string> match_response(stream, function, item) {  │    │
│  │      for (const auto& rule : conditions) {                  │    │
│  │          if (match_condition(rule.condition,                │    │
│  │                              stream, function, item)) {     │    │
│  │              return rule.response_name;                     │    │
│  │          }                                                  │    │
│  │      }                                                      │    │
│  │      return nullopt;                                        │    │
│  │  }                                                          │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  match_condition() 匹配逻辑：                                       │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  1. 检查消息是否匹配：                                      │    │
│  │     - 若条件是 SxFy 格式，直接比较 stream/function          │    │
│  │     - 否则按消息名查找，比较其 stream/function              │    │
│  │                                                             │    │
│  │  2. 若有索引和期望值，检查 Item：                           │    │
│  │     - 仅当根节点为 List 时允许索引匹配                      │    │
│  │     - 使用先序遍历找到第 N 个元素                           │    │
│  │     - 调用 items_equal() 比较元素值                         │    │
│  │                                                             │    │
│  │  3. 全部检查通过则返回 true。                               │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  先序遍历查找：find_preorder_nth(root, n)                           │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  // 递归先序遍历，返回第 n 个节点（1-based）                │    │
│  │  bool Walk::run(item, n, cur, found) {                      │    │
│  │      ++cur;                                                 │    │
│  │      if (cur == n) { found = &item; return true; }          │    │
│  │                                                             │    │
│  │      if (item.is_list()) {                                  │    │
│  │          for (child : item) {                               │    │
│  │              if (run(child, n, cur, found)) return true;    │    │
│  │          }                                                  │    │
│  │      }                                                      │    │
│  │      return false;                                          │    │
│  │  }                                                          │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 7.4 Item 比较语义

```
┌─────────────────────────────────────────────────────────────────────┐
│                    items_equal() 比较语义                           │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  浮点数：使用容差比较（提升规则易用性）                             │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  constexpr float kAbsTol = 0.0001f;                         │    │
│  │                                                             │    │
│  │  bool float_almost_equal(float a, float b) {                │    │
│  │      return fabs(a - b) <= kAbsTol;                         │    │
│  │  }                                                          │    │
│  │                                                             │    │
│  │  bool double_almost_equal(double a, double b) {             │    │
│  │      return fabs(a - b) <= kAbsTol;                         │    │
│  │  }                                                          │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  其他类型：使用 ii::Item 的严格相等                                 │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  bool items_equal(const Item& a, const Item& b) {           │    │
│  │      // F4 容差比较                                         │    │
│  │      if (auto* af4 = a.get_if<F4>()) {                      │    │
│  │          auto* bf4 = b.get_if<F4>();                        │    │
│  │          if (!bf4 || af4->size() != bf4->size())            │    │
│  │              return false;                                  │    │
│  │          for (i : af4->values)                              │    │
│  │              if (!float_almost_equal(af4[i], bf4[i]))       │    │
│  │                  return false;                              │    │
│  │          return true;                                       │    │
│  │      }                                                      │    │
│  │                                                             │    │
│  │      // F8 容差比较（同上）                                 │    │
│  │      ...                                                    │    │
│  │                                                             │    │
│  │      // 其他类型：严格相等                                  │    │
│  │      return a == b;                                         │    │
│  │  }                                                          │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  设计考量：                                                         │
│  - 设备端浮点运算可能有微小误差                                     │
│  - 容差比较避免规则无法命中                                         │
│  - 其他类型保持严格匹配，确保行为可预测                             │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 7.5 SMLX：模板渲染与主动发送

SMLX v0 的核心是“模板 + 上下文渲染”，并以最小侵入方式复用现有的 SECS-II 编解码：

- `TemplateItem`（AST）→ `render_item()` → `secs::ii::Item`（结构化 Item）
- `secs::ii::Item` → `secs::ii::encode(item, out_bytes)` → `SECS-II body bytes`

为方便业务侧“主动发送”，运行时提供一站式接口 `Runtime::encode_message_body()`：

```
RenderContext ctx;
ctx.set("MDLN", secs::ii::Item::ascii("WET.01"));
ctx.set("SVIDS", secs::ii::Item::u2(std::vector<std::uint16_t>{100, 200}));

vector<byte> body;
uint8_t s, f;
bool w;

// 1) 查找模板（按消息名或直接 "SxFy"）
// 2) 渲染占位符（缺失变量/类型不匹配会返回 sml.render）
// 3) 编码为 SECS-II body bytes
ec = runtime.encode_message_body("req", ctx, body, &s, &f, &w);

// 业务侧根据 w 决定 async_send / async_request
```

补充：

- `render_item()` 的错误码域为 `sml.render`（missing_variable/type_mismatch），并会在 OOM 等异常场景下返回 `secs.core/out_of_memory`（见 `src/sml/render.cpp`）。
- 代码侧完整用法可参考示例：`examples/smlx_active_send_example.cpp`。

---

## 8. 错误处理

```
┌─────────────────────────────────────────────────────────────────────┐
│                    SML 错误码系统                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Lexer 错误码 (lexer_errc)：                                        │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  ok                  : 成功                                 │    │
│  │  unterminated_string : 未闭合的字符串字面量                 │    │
│  │  unterminated_comment: 未闭合的块注释                       │    │
│  │  invalid_character   : 非法字符                             │    │
│  │  invalid_hex_literal : 无效的十六进制字面量                 │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  Parser 错误码 (parser_errc)：                                      │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  ok                    : 成功                               │    │
│  │  unexpected_token      : 非预期的 token                     │    │
│  │  expected_item         : 期望 Item                          │    │
│  │  expected_identifier   : 期望标识符                         │    │
│  │  expected_number       : 期望数字                           │    │
│  │  invalid_stream_function: 无效的 SxFy 格式                  │    │
│  │  unclosed_item         : 未闭合的 Item                      │    │
│  │  invalid_condition     : 无效的条件表达式                   │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  Render 错误码 (render_errc，域名：sml.render)：                     │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  ok               : 成功                                    │    │
│  │  missing_variable : 缺少变量（占位符未注入）                │    │
│  │  type_mismatch    : 类型不匹配（变量 Item 类型不一致）       │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  错误信息格式：                                                     │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  struct LexerResult / ParseResult {                         │    │
│  │      error_code ec;          // 错误码                      │    │
│  │      uint32_t error_line;    // 错误行号（1-based）         │    │
│  │      uint32_t error_column;  // 错误列号（1-based）         │    │
│  │      string error_message;   // 错误描述                    │    │
│  │  };                                                         │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 9. 完整使用示例

```
┌─────────────────────────────────────────────────────────────────────┐
│                    SML 使用示例                                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  【加载 SML 配置】                                                  │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  const char* sml_source = R"(                               │    │
│  │      // 通信建立                                            │    │
│  │      // SMLX：把 MDLN 作为占位符，在运行时注入               │    │
│  │      establish: S1F13 W <L <A MDLN> <A "1.0.0">>.           │    │
│  │      establish_ack: S1F14 <L <U2 0> <L <A "EQ"> <A "2.0">>>. │   │
│  │                                                             │    │
│  │      // 条件响应                                            │    │
│  │      if (S1F13) establish_ack.                              │    │
│  │                                                             │    │
│  │      // 心跳                                                │    │
│  │      heartbeat: S1F1 W.                                     │    │
│  │      every 30 send heartbeat.                               │    │
│  │  )";                                                        │    │
│  │                                                             │    │
│  │  sml::Runtime runtime;                                      │    │
│  │  auto ec = runtime.load(sml_source);                        │    │
│  │  if (ec) {                                                  │    │
│  │      // 解析失败                                            │    │
│  │      return ec;                                             │    │
│  │  }                                                          │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  【渲染并编码（用于主动发送）】                                     │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  // 注入占位符变量（变量值使用 secs::ii::Item 表达）         │    │
│  │  sml::RenderContext ctx;                                    │    │
│  │  ctx.set("MDLN", ii::Item::ascii("WET.01"));                │    │
│  │                                                             │    │
│  │  // 一站式：查找模板 + 渲染 + SECS-II 编码                   │    │
│  │  vector<byte> body;                                         │    │
│  │  uint8_t stream = 0, function = 0;                          │    │
│  │  bool w_bit = false;                                        │    │
│  │  auto ec = runtime.encode_message_body(                     │    │
│  │      "establish", ctx, body, &stream, &function, &w_bit      │    │
│  │  );                                                         │    │
│  │                                                             │    │
│  │  if (!ec) {                                                 │    │
│  │      // 根据 w_bit 选择 send/request（示例只展示 send）       │    │
│  │      session.async_send(stream, function, body);            │    │
│  │  }                                                          │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  【条件响应匹配】                                                   │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  // 收到消息时查找响应                                      │    │
│  │  secs::ii::Item decoded{secs::ii::List{}};                  │    │
│  │  {                                                          │    │
│  │      auto [dec_ec, decoded_opt] =                            │    │
│  │          secs::utils::decode_one_item_if_any(                │    │
│  │              secs::core::bytes_view{msg.body.data(), msg.body.size()});│   │
│  │      if (dec_ec) { /* handle error */ }                      │    │
│  │      if (decoded_opt.has_value()) {                          │    │
│  │          decoded = std::move(decoded_opt->item);              │    │
│  │      }                                                       │    │
│  │  }                                                           │    │
│  │  auto response_name = runtime.match_response(                │    │
│  │      msg.stream, msg.function, decoded                       │    │
│  │  );                                                         │    │
│  │                                                             │    │
│  │  if (response_name) {                                       │    │
│  │      // 取响应模板并编码（同样支持占位符渲染）                │    │
│  │      vector<byte> rsp_body;                                 │    │
│  │      uint8_t rsp_s = 0, rsp_f = 0;                          │    │
│  │      bool rsp_w = false;                                    │    │
│  │      auto ec = runtime.encode_message_body(                 │    │
│  │          *response_name, ctx, rsp_body, &rsp_s, &rsp_f, &rsp_w│   │
│  │      );                                                     │    │
│  │      if (!ec) {                                             │    │
│  │          co_await session.async_send(                        │    │
│  │              rsp_s, rsp_f,                                   │    │
│  │              secs::core::bytes_view{rsp_body.data(), rsp_body.size()});│   │
│  │      }                                                      │    │
│  │  }                                                          │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  【定时发送】                                                       │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  for (const auto& timer : runtime.timers()) {               │    │
│  │      // 设置定时器，每 timer.interval_seconds 秒发送        │    │
│  │      schedule_timer(timer.interval_seconds, [=]() {          │    │
│  │          vector<byte> body;                                 │    │
│  │          uint8_t s = 0, f = 0;                              │    │
│  │          bool w = false;                                    │    │
│  │          auto ec = runtime.encode_message_body(             │    │
│  │              timer.message_name, ctx, body, &s, &f, &w       │    │
│  │          );                                                 │    │
│  │          if (!ec) {                                         │    │
│  │              session.async_send(s, f, body);                │    │
│  │          }                                                  │    │
│  │      });                                                    │    │
│  │  }                                                          │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 10. 源文件清单

| 文件 | 行数 | 说明 |
|------|------|------|
| `include/secs/sml/token.hpp` | 138 | Token 类型定义 |
| `include/secs/sml/ast.hpp` | 236 | AST 数据结构（含 TemplateItem/VarRef） |
| `include/secs/sml/lexer.hpp` | 85 | Lexer 接口 |
| `include/secs/sml/parser.hpp` | 97 | Parser 接口 |
| `include/secs/sml/render.hpp` | 88 | SMLX 渲染接口（RenderContext/render_item） |
| `include/secs/sml/runtime.hpp` | 200 | Runtime 接口（含 encode_message_body） |
| `src/sml/lexer.cpp` | 385 | 词法分析实现 |
| `src/sml/parser.cpp` | 871 | 语法分析实现 |
| `src/sml/render.cpp` | 228 | SMLX 渲染实现 |
| `src/sml/runtime.cpp` | 373 | 运行时实现 |
