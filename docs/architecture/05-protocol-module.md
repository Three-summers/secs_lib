# Protocol 模块详细实现原理

> 文档生成日期：2026-01-07
> 基于源码版本：当前 main 分支

## 1. 模块概述

`secs::protocol` 模块是 HSMS 与 SECS-I 之上的统一抽象层，提供：

- **统一会话**：`Session` 类统一 HSMS 与 SECS-I 的发送/请求/接收接口
- **消息路由**：`Router` 基于 (Stream, Function) 分发入站消息到处理器
- **事务标识**：`SystemBytes` 分配器保证请求-响应匹配的唯一性

```
┌─────────────────────────────────────────────────────────────────────┐
│                     secs::protocol 模块                             │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                    Session（统一会话）                       │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │   │
│  │  │ async_send  │  │async_request│  │   async_run         │  │   │
│  │  │ W=0 不等回  │  │ W=1 等回应  │  │   接收循环          │  │   │
│  │  └─────────────┘  └─────────────┘  └─────────────────────┘  │   │
│  └───────────────────────────▲─────────────────────────────────┘   │
│                              │                                      │
│  ┌───────────────────────────┼─────────────────────────────────┐   │
│  │                    后端抽象（Backend）                       │   │
│  │      ┌──────────────┐           ┌──────────────┐            │   │
│  │      │ HSMS Session │           │ SECS-I SM    │            │   │
│  │      │ （全双工）    │           │ （半双工）    │            │   │
│  │      └──────────────┘           └──────────────┘            │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  ┌─────────────────┐  ┌──────────────────────────────────────────┐ │
│  │   Router        │  │          SystemBytes                     │ │
│  │ (S,F)->Handler  │  │   分配/追踪/释放/回绕                    │ │
│  └─────────────────┘  └──────────────────────────────────────────┘ │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 2. DataMessage 数据结构

### 2.1 消息抽象

```
┌─────────────────────────────────────────────────────────────────────┐
│                    DataMessage 结构                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  struct DataMessage {                                               │
│      uint8_t stream;           // 流号 (0~127)                     │
│      uint8_t function;         // 功能号                           │
│      bool w_bit;               // 等待位 (true=需要回应)           │
│      uint32_t system_bytes;    // 事务标识                         │
│      vector<byte> body;        // 消息体 (SECS-II 编码)            │
│  };                                                                 │
│                                                                     │
│  Primary/Secondary 判断：                                          │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  is_primary() = (function & 0x01) != 0                      │    │
│  │                                                             │    │
│  │  Function   奇偶性    消息类型                              │    │
│  │  ─────────────────────────────────────────                  │    │
│  │  F1, F3...  奇数      Primary（请求）                       │    │
│  │  F2, F4...  偶数      Secondary（响应）                     │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  Secondary Function 计算：                                         │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  secondary_function(F) = F + 1                              │    │
│  │                                                             │    │
│  │  例如：                                                     │    │
│  │  - S1F1 的响应是 S1F2                                       │    │
│  │  - S2F33 的响应是 S2F34                                     │    │
│  │                                                             │    │
│  │  特例：F=255 (0xFF) 不能计算 secondary                      │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.2 消息流向

```
┌─────────────────────────────────────────────────────────────────────┐
│                    消息流向与 W-bit 语义                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Primary (W=0)：单向通知                                           │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  Host                              Equipment                │    │
│  │    │                                    │                   │    │
│  │    │──── SxFy (W=0) ──────────────────>│                   │    │
│  │    │           不等待回应               │                   │    │
│  │    │                                    │                   │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  Primary (W=1)：请求-响应                                          │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  Host                              Equipment                │    │
│  │    │                                    │                   │    │
│  │    │──── SxFy (W=1, SB=100) ──────────>│                   │    │
│  │    │           等待回应 (T3)            │                   │    │
│  │    │                                    │ 处理...           │    │
│  │    │<─── SxF(y+1) (SB=100) ────────────│                   │    │
│  │    │           相同 SystemBytes         │                   │    │
│  │    │                                    │                   │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  SB = SystemBytes，用于关联请求与响应                              │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 3. SystemBytes 分配器

### 3.1 设计目标

```
┌─────────────────────────────────────────────────────────────────────┐
│                    SystemBytes 分配器设计                           │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  职责：                                                             │
│  1. 分配唯一的 SystemBytes 值                                      │
│  2. 追踪当前在用的 SystemBytes                                     │
│  3. 释放后允许重用                                                  │
│  4. 处理 wrap-around（回绕到起始值）                               │
│                                                                     │
│  约束：                                                             │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  - 0 作为保留值，永不分配                                   │    │
│  │  - 有效范围：1 ~ max_value (默认 UINT32_MAX)                │    │
│  │  - 同一时刻不会分配相同的值                                 │    │
│  │  - 线程安全（内部使用 mutex 保护）                          │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  内部数据结构：                                                     │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  uint32_t next_;                    // 下一个候选值          │    │
│  │  uint32_t max_;                     // 最大允许值            │    │
│  │  deque<uint32_t> free_;             // 已释放可重用队列      │    │
│  │  unordered_set<uint32_t> in_use_;   // 当前在用集合          │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 3.2 分配流程

```
┌─────────────────────────────────────────────────────────────────────┐
│                    allocate(out) 流程                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. 优先复用已释放值：                                              │
│     ┌────────────────────────────────────────────────────────────┐ │
│     │  if (!free_.empty()) {                                     │ │
│     │      out = free_.front();                                  │ │
│     │      free_.pop_front();                                    │ │
│     │      in_use_.insert(out);                                  │ │
│     │      return ok;                                            │ │
│     │  }                                                         │ │
│     └────────────────────────────────────────────────────────────┘ │
│                                                                     │
│  2. 检查是否已耗尽：                                                │
│     ┌────────────────────────────────────────────────────────────┐ │
│     │  if (in_use_.size() >= max_) {                             │ │
│     │      return buffer_overflow;  // 极端情况：全部在用        │ │
│     │  }                                                         │ │
│     └────────────────────────────────────────────────────────────┘ │
│                                                                     │
│  3. 从 next_ 递增寻找未占用值：                                     │
│     ┌────────────────────────────────────────────────────────────┐ │
│     │  for (i = 0; i < in_use_.size() + 2; ++i) {                │ │
│     │      candidate = next_candidate_();  // next_++ 并回绕     │ │
│     │      if (in_use_.insert(candidate).second) {               │ │
│     │          out = candidate;                                  │ │
│     │          return ok;                                        │ │
│     │      }                                                     │ │
│     │  }                                                         │ │
│     └────────────────────────────────────────────────────────────┘ │
│                                                                     │
│  next_candidate_() 回绕逻辑：                                       │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  if (next_ == max_) {                                       │    │
│  │      next_ = 1;  // 回绕到起始值                            │    │
│  │  } else {                                                   │    │
│  │      next_ += 1;                                            │    │
│  │  }                                                          │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 3.3 释放流程

```
┌─────────────────────────────────────────────────────────────────────┐
│                    release(system_bytes) 流程                       │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  1. 校验有效性：                                            │    │
│  │     if (system_bytes == 0 || system_bytes > max_) return;   │    │
│  │                                                             │    │
│  │  2. 从 in_use_ 移除：                                       │    │
│  │     if (in_use_.erase(system_bytes) == 0) return;           │    │
│  │     // 不在 in_use_ 中，可能是重复释放                      │    │
│  │                                                             │    │
│  │  3. 加入 free_ 队列：                                       │    │
│  │     free_.push_back(system_bytes);                          │    │
│  │     // 允许后续 allocate() 复用                             │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  状态变化示意：                                                     │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  Before release(5):                                         │    │
│  │    in_use_ = {1, 3, 5, 7}                                   │    │
│  │    free_   = [2]                                            │    │
│  │                                                             │    │
│  │  After release(5):                                          │    │
│  │    in_use_ = {1, 3, 7}                                      │    │
│  │    free_   = [2, 5]                                         │    │
│  │                      ^                                      │    │
│  │                  下次优先分配 2，然后 5                      │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 4. Router 消息路由器

### 4.1 路由机制

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Router 路由机制                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Key 计算：                                                         │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  Key = (stream << 8) | function                             │    │
│  │                                                             │    │
│  │  例如：                                                     │    │
│  │  - S1F1  -> Key = 0x0101                                    │    │
│  │  - S2F33 -> Key = 0x0221                                    │    │
│  │  - S6F11 -> Key = 0x060B                                    │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  Handler 签名：                                                     │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  using HandlerResult = pair<error_code, vector<byte>>;      │    │
│  │  using Handler = function<awaitable<HandlerResult>(         │    │
│  │      const DataMessage&                                     │    │
│  │  )>;                                                        │    │
│  │                                                             │    │
│  │  // Handler 返回值说明：                                    │    │
│  │  // - error_code: 处理错误码                                │    │
│  │  // - vector<byte>: 响应消息体（若 W=1 则用于自动回复）     │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  查找优先级：                                                       │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  1. 精确匹配 handlers_[(stream,function)]                   │    │
│  │  2. 若无匹配，尝试 default_handler_                         │    │
│  │  3. 均无，返回 nullopt                                      │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 4.2 注册与查找

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Router API 使用                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  注册处理器：                                                       │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  // 注册 S1F1 处理器                                        │    │
│  │  router.set(1, 1, [](const DataMessage& msg)               │    │
│  │      -> awaitable<HandlerResult> {                          │    │
│  │      // 处理 S1F1，返回响应体                               │    │
│  │      vector<byte> response = ...;                           │    │
│  │      co_return {error_code{}, response};                    │    │
│  │  });                                                        │    │
│  │                                                             │    │
│  │  // 注册默认处理器（处理未注册的消息）                      │    │
│  │  router.set_default([](const DataMessage& msg)             │    │
│  │      -> awaitable<HandlerResult> {                          │    │
│  │      // 返回通用错误响应                                    │    │
│  │      co_return {make_error_code(errc::invalid_argument), {}};│   │
│  │  });                                                        │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  线程安全说明：                                                     │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  - 所有操作（set/find/erase）都使用 mutex 保护               │    │
│  │  - find() 返回 Handler 的拷贝，避免持锁执行协程             │    │
│  │  - 支持在运行时动态注册/注销处理器                          │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 5. Session 统一会话

### 5.1 后端抽象

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Session 后端抽象                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Session 支持两种后端：                                             │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  Backend::hsms                                               │   │
│  │  ├── 全双工：可同时收发                                     │   │
│  │  ├── 使用 hsms::Session 的 async_send/async_receive_data    │   │
│  │  ├── 自动启动 async_run() 接收循环                          │   │
│  │  └── 多请求可并发等待                                       │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  Backend::secs1                                              │   │
│  │  ├── 半双工：同一时刻只能收或发                             │   │
│  │  ├── 使用 secs1::StateMachine 的 async_send/async_receive   │   │
│  │  ├── 请求侧自己驱动接收循环                                 │   │
│  │  └── 不支持并发请求（返回 invalid_argument）                │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  构造函数：                                                         │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  // HSMS 后端                                               │    │
│  │  Session(hsms::Session& hsms, uint16_t session_id, options);│    │
│  │                                                             │    │
│  │  // SECS-I 后端                                             │    │
│  │  Session(secs1::StateMachine& sm, uint16_t device_id, opts);│    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 5.2 会话配置

```
┌─────────────────────────────────────────────────────────────────────┐
│                    SessionOptions 配置                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  struct SessionOptions {                                            │
│      duration t3{45s};             // 回复超时                      │
│      duration poll_interval{10ms}; // 接收循环轮询间隔             │
│      bool secs1_reverse_bit{false};// SECS-I R-bit 方向位          │
│      DumpOptions dump{};         // 运行时报文 dump（调试用途）     │
│  };                                                                 │
│                                                                     │
│  T3 超时（回复超时）：                                              │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  async_request() 发送 W=1 的消息后，                        │    │
│  │  最多等待 T3 时间收到响应。                                 │    │
│  │  超时返回 errc::timeout。                                   │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  poll_interval（轮询间隔）：                                        │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  async_run() 接收循环中，                                   │    │
│  │  若 async_receive 返回 timeout，继续循环。                  │    │
│  │  用于定期检查 stop_requested_ 避免永久阻塞。                │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  secs1_reverse_bit（R-bit）：                                       │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  - false (R=0): Host -> Equipment 方向                      │    │
│  │  - true  (R=1): Equipment -> Host 方向                      │    │
│  │  仅对 SECS-I 后端有效。                                     │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  dump（运行时报文 dump）：                                          │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  - enable：总开关（默认 false）                              │    │
│  │  - dump_tx/dump_rx：分别控制发送/接收方向                    │    │
│  │  - sink：可选输出回调；为空则默认走 spdlog(INFO)             │    │
│  │  - hsms/secs1：各自 dump 细节（含可选 SECS-II 解码）         │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 5.2.1 DumpOptions（运行时报文 dump）

`DumpOptions` 的目标是把“抓包/日志/联调期常见的报文分析”内置到协议层会话中，做到：

- **运行时可开关**：默认关闭，避免对生产路径产生额外开销
- **可选输出位置**：默认走 spdlog；也可通过 `sink` 将 dump 写入 stdout/文件/环形缓冲区
- **统一后端表现**：HSMS 与 SECS-I 通过同一配置项输出解析结果

结构概览（字段以源码为准）：

```
┌─────────────────────────────────────────────────────────────────────┐
│                    SessionOptions::DumpOptions                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  struct DumpOptions {                                               │
│      bool enable{false};        // 总开关                           │
│      bool dump_tx{true};        // 发送方向                         │
│      bool dump_rx{true};        // 接收方向                         │
│                                                                     │
│      // 输出 sink：若为空则默认 spdlog(INFO)                        │
│      using SinkFn = void (*)(void *user,                            │
│                              const char *data,                      │
│                              size_t size) noexcept;                 │
│      SinkFn sink{nullptr};                                          │
│      void *sink_user{nullptr};                                      │
│                                                                     │
│      // 后端细节：复用 secs::utils 的 dump 选项                      │
│      utils::HsmsDumpOptions hsms{};                                  │
│      utils::Secs1DumpOptions secs1{};                                │
│  };                                                                 │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

注意点：

- HSMS 后端 dump 内部会 **额外 encode 一次 HSMS frame**，仅用于把字段解析输出（不影响真实收发路径）
- SECS-I 后端 dump 输出为“消息级”（header+body），不包含 ENQ/EOT/ACK/NAK 控制字节

### 5.3 发送流程（async_send）

```
┌─────────────────────────────────────────────────────────────────────┐
│                    async_send(stream, function, body) 流程          │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  用途：发送 W=0 的 primary 消息（不等待回应）                       │
│                                                                     │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  1. 参数校验：                                              │    │
│  │     - stream <= 0x7F (有效范围)                             │    │
│  │     - function 为奇数且非 0 (primary function)              │    │
│  │                                                             │    │
│  │  2. 分配 SystemBytes：                                      │    │
│  │     system_bytes_.allocate(sb);                             │    │
│  │                                                             │    │
│  │  3. 构造 DataMessage：                                      │    │
│  │     {stream, function, w_bit=false, sb, body}               │    │
│  │                                                             │    │
│  │  4. 发送消息：                                              │    │
│  │     async_send_message_(msg);                               │    │
│  │                                                             │    │
│  │  5. 释放 SystemBytes：                                      │    │
│  │     system_bytes_.release(sb);                              │    │
│  │                                                             │    │
│  │  6. 返回结果。                                              │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  时序：                                                             │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  [调用方]                      [Session]                   │    │
│  │     │                             │                        │    │
│  │     │──── async_send() ──────────>│                        │    │
│  │     │                             │──allocate sb           │    │
│  │     │                             │──send message          │    │
│  │     │                             │──release sb            │    │
│  │     │<─── error_code ─────────────│                        │    │
│  │     │      (立即返回)             │                        │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 5.4 请求流程（async_request）

```
┌─────────────────────────────────────────────────────────────────────┐
│                    async_request(stream, function, body) 流程       │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  用途：发送 W=1 的 primary 消息，等待 secondary 响应                │
│                                                                     │
│  【HSMS 后端流程】                                                  │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  1. 校验参数（同 async_send）                               │    │
│  │                                                             │    │
│  │  2. 计算 expected_function = function + 1                   │    │
│  │                                                             │    │
│  │  3. 分配 SystemBytes                                        │    │
│  │                                                             │    │
│  │  4. 确保接收循环启动：ensure_hsms_run_loop_started_()       │    │
│  │     └── 首次调用时 co_spawn async_run()                     │    │
│  │                                                             │    │
│  │  5. 创建 Pending 对象并注册到 pending_[sb]                  │    │
│  │     ┌──────────────────────────────────────────────────┐   │    │
│  │     │  struct Pending {                                │   │    │
│  │     │      expected_stream, expected_function;         │   │    │
│  │     │      Event ready;                                │   │    │
│  │     │      error_code ec;                              │   │    │
│  │     │      optional<DataMessage> response;             │   │    │
│  │     │  };                                              │   │    │
│  │     └──────────────────────────────────────────────────┘   │    │
│  │                                                             │    │
│  │  6. 发送消息                                                │    │
│  │                                                             │    │
│  │  7. 等待 pending->ready.async_wait(T3)                      │    │
│  │     └── 由 async_run() 收到响应后唤醒                       │    │
│  │                                                             │    │
│  │  8. 清理 pending_[sb]，释放 SystemBytes                     │    │
│  │                                                             │    │
│  │  9. 返回响应消息                                            │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  【SECS-I 后端流程】                                                │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  1~3. 同上                                                  │    │
│  │                                                             │    │
│  │  4. 发送消息                                                │    │
│  │                                                             │    │
│  │  5. 循环接收直到匹配或超时：                                │    │
│  │     for (;;) {                                              │    │
│  │         if (now >= deadline) return timeout;                │    │
│  │                                                             │    │
│  │         msg = async_receive_message_(remaining);            │    │
│  │                                                             │    │
│  │         if (msg matches expected response) {                │    │
│  │             return msg;                                     │    │
│  │         }                                                   │    │
│  │                                                             │    │
│  │         // 非匹配消息：可能是对端的 primary                 │    │
│  │         handle_inbound_(msg);  // 交给 Router 处理          │    │
│  │     }                                                       │    │
│  │                                                             │    │
│  │  6. 释放 SystemBytes，返回结果                              │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 5.5 接收循环（async_run）

```
┌─────────────────────────────────────────────────────────────────────┐
│                    async_run() 接收循环                             │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  主要用于 HSMS 后端的持续接收：                                     │
│                                                                     │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  while (!stop_requested_) {                                 │    │
│  │      auto [ec, msg] = async_receive_message_(poll_interval);│    │
│  │                                                             │    │
│  │      if (ec == timeout) continue;  // 轮询检查 stop         │    │
│  │      if (ec) {                                              │    │
│  │          cancel_all_pending_(ec);  // 错误时取消所有挂起    │    │
│  │          stop_requested_ = true;                            │    │
│  │          break;                                             │    │
│  │      }                                                      │    │
│  │                                                             │    │
│  │      handle_inbound_(msg);  // 处理入站消息                 │    │
│  │  }                                                          │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  handle_inbound_(msg) 处理逻辑：                                    │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  1. 尝试匹配挂起请求：                                      │    │
│  │     if (try_fulfill_pending_(msg)) return;                  │    │
│  │                                                             │    │
│  │  2. 若是未匹配的 secondary：忽略                            │    │
│  │     if (msg.is_secondary()) return;                         │    │
│  │                                                             │    │
│  │  3. 查找 Router 处理器：                                    │    │
│  │     handler = router_.find(stream, function);               │    │
│  │     if (!handler) return;  // 无处理器，忽略                │    │
│  │                                                             │    │
│  │  4. 执行处理器：                                            │    │
│  │     [ec, rsp_body] = handler(msg);                          │    │
│  │                                                             │    │
│  │  5. 若 W=1，自动发送响应：                                  │    │
│  │     if (msg.w_bit) {                                        │    │
│  │         rsp.function = msg.function + 1;                    │    │
│  │         rsp.system_bytes = msg.system_bytes;                │    │
│  │         async_send_message_(rsp);                           │    │
│  │     }                                                       │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 5.6 请求-响应匹配

```
┌─────────────────────────────────────────────────────────────────────┐
│                    请求-响应匹配机制                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  try_fulfill_pending_(msg) 匹配条件：                               │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  1. msg.system_bytes 在 pending_ 中有对应项                 │    │
│  │  2. msg.is_secondary() == true                              │    │
│  │  3. msg.w_bit == false                                      │    │
│  │  4. msg.stream == pending->expected_stream                  │    │
│  │  5. msg.function == pending->expected_function              │    │
│  │                                                             │    │
│  │  全部满足 -> 填充 pending->response，唤醒等待者             │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  时序图（HSMS 后端）：                                              │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  [async_request]       [async_run]           [对端]        │    │
│  │       │                     │                    │         │    │
│  │       │  pending_[sb]=...   │                    │         │    │
│  │       │────────────────────>│                    │         │    │
│  │       │                     │                    │         │    │
│  │       │──── send S1F1 ──────│────────────────────>│        │    │
│  │       │                     │                    │         │    │
│  │       │  ready.async_wait() │                    │ 处理... │    │
│  │       │<--------------------|                    │         │    │
│  │       │     (挂起)          │                    │         │    │
│  │       │                     │<── S1F2 ──────────│         │    │
│  │       │                     │                    │         │    │
│  │       │                     │ try_fulfill_pending_()       │    │
│  │       │                     │  -> pending->response = msg  │    │
│  │       │                     │  -> pending->ready.set()     │    │
│  │       │                     │                    │         │    │
│  │       │<──────────────── 唤醒│                    │         │    │
│  │       │                     │                    │         │    │
│  │       │  return response    │                    │         │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 6. 并发模型

```
┌─────────────────────────────────────────────────────────────────────┐
│                    并发模型对比                                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  【HSMS 后端 - 全双工】                                             │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │                                                             │    │
│  │    async_request #1 ──┐                                     │    │
│  │                       │   pending_[sb1]                     │    │
│  │    async_request #2 ──┼── pending_[sb2] ──> async_run ──>  │    │
│  │                       │   pending_[sb3]        │            │    │
│  │    async_request #3 ──┘                        │            │    │
│  │                                                │            │    │
│  │                                         收到响应时           │    │
│  │                                         按 SystemBytes       │    │
│  │                                         唤醒对应等待者       │    │
│  │                                                             │    │
│  │  优点：多请求可并发等待，吞吐量高                           │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  【SECS-I 后端 - 半双工】                                           │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │                                                             │    │
│  │    async_request ─────> send ────> recv ────> 返回          │    │
│  │           │                                                 │    │
│  │           └── 请求侧自己驱动收发，不使用 async_run           │    │
│  │                                                             │    │
│  │    注意事项：                                               │    │
│  │    - 同一时刻只能有一个收发操作                             │    │
│  │    - 并发调用会返回 invalid_argument                        │    │
│  │    - 若需多线程访问，建议使用 strand 串行化                 │    │
│  │                                                             │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 7. 错误处理

```
┌─────────────────────────────────────────────────────────────────────┐
│                    协议层错误处理                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  返回的错误码（来自 secs::core::errc）：                           │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  invalid_argument:                                          │    │
│  │    - stream > 0x7F                                          │    │
│  │    - function 为偶数或 0                                    │    │
│  │    - SECS-I 后端并发调用                                    │    │
│  │                                                             │    │
│  │  timeout:                                                   │    │
│  │    - async_request 等待响应超过 T3                          │    │
│  │                                                             │    │
│  │  buffer_overflow:                                           │    │
│  │    - SystemBytes 空间耗尽（极端情况）                       │    │
│  │                                                             │    │
│  │  cancelled:                                                 │    │
│  │    - stop() 被调用                                          │    │
│  │    - 底层传输层错误导致 cancel_all_pending_()               │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  cancel_all_pending_(reason) 行为：                                 │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  当接收循环遇到错误或 stop() 被调用时：                     │    │
│  │                                                             │    │
│  │  1. 取出所有 pending_ 项                                    │    │
│  │  2. 设置每项的 ec = reason                                  │    │
│  │  3. 调用 ready.cancel()                                     │    │
│  │  4. 释放对应的 SystemBytes                                  │    │
│  │                                                             │    │
│  │  确保所有等待的 async_request 协程能及时返回                │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 8. 完整使用示例

```
┌─────────────────────────────────────────────────────────────────────┐
│                    协议层使用示例                                   │
├──────────────��──────────────────────────────────────────────────────┤
│                                                                     │
│  【Host 端示例 - 发起请求】                                         │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  // 创建 HSMS Session                                       │    │
│  │  hsms::Session hsms_session(...);                           │    │
│  │  protocol::Session session(hsms_session, /*session_id=*/1); │    │
│  │                                                             │    │
│  │  // 发送 S1F13 (通信建立请求)，等待 S1F14                   │    │
│  │  auto body = ii::encode(Item::list({                        │    │
│  │      Item::ascii(""),       // MDLN                         │    │
│  │      Item::ascii("1.0.0")   // SOFTREV                      │    │
│  │  }));                                                       │    │
│  │                                                             │    │
│  │  auto [ec, rsp] = co_await session.async_request(           │    │
│  │      1, 13, body                                            │    │
│  │  );                                                         │    │
│  │  if (!ec) {                                                 │    │
│  │      // 解析 S1F14 响应                                     │    │
│  │      auto item = ii::decode_one(rsp.body);                  │    │
│  │  }                                                          │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  【Equipment 端示例 - 注册处理器】                                  │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  // 注册 S1F13 处理器                                       │    │
│  │  session.router().set(1, 13,                                │    │
│  │      [](const DataMessage& msg) -> awaitable<HandlerResult> │    │
│  │  {                                                          │    │
│  │      // 解析请求                                            │    │
│  │      auto req_item = ii::decode_one(msg.body);              │    │
│  │                                                             │    │
│  │      // 构造响应 (S1F14)                                    │    │
│  │      auto rsp = Item::list({                                │    │
│  │          Item::u2({0}),                    // COMMACK=0     │    │
│  │          Item::list({                                       │    │
│  │              Item::ascii("EQUIP_MODEL"),   // MDLN          │    │
│  │              Item::ascii("2.0.0")          // SOFTREV       │    │
│  │          })                                                 │    │
│  │      });                                                    │    │
│  │      auto body = ii::encode(rsp);                           │    │
│  │      co_return {error_code{}, body};                        │    │
│  │  });                                                        │    │
│  │                                                             │    │
│  │  // 启动接收循环                                            │    │
│  │  co_await session.async_run();                              │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 9. 源文件清单

| 文件 | 行数 | 说明 |
|------|------|------|
| `include/secs/protocol/router.hpp` | ~74 | Router/DataMessage 定义 |
| `include/secs/protocol/session.hpp` | ~146 | Session 接口 |
| `include/secs/protocol/system_bytes.hpp` | ~70 | SystemBytes 分配器接口 |
| `src/protocol/router.cpp` | ~59 | Router 实现 |
| `src/protocol/session.cpp` | ~509 | Session 实现 |
| `src/protocol/system_bytes.cpp` | ~130 | SystemBytes 分配器实现 |
