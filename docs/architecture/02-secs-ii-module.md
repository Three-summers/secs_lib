# SECS-II 模块详细实现原理

> 文档生成日期：2026-01-06
> 基于源码版本：当前 main 分支
> 对应标准：SEMI E5（SECS-II Message Content）

## 1. 模块概述

`secs::ii` 模块实现 SECS-II 消息内容层（SEMI E5），提供：

- **数据模型**：`Item` 类型系统（强类型 AST）
- **编解码**：`encode()` / `decode_one()` 函数
- **资源限制**：`DecodeLimits` 防止恶意输入

```
┌─────────────────────────────────────────────────────────────────────┐
│                        secs::ii 模块                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                    Item（强类型 AST）                        │   │
│  │  ┌────────┬────────┬────────┬────────┬────────┬────────┐   │   │
│  │  │  List  │ ASCII  │ Binary │Boolean │ I1-I8  │ U1-U8  │   │   │
│  │  │        │        │        │        │ F4/F8  │        │   │   │
│  │  └────────┴────────┴────────┴────────┴────────┴────────┘   │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                    编解码层                                   │   │
│  │  encode(Item) -> bytes    |    decode_one(bytes) -> Item    │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 2. SECS-II 数据格式（SEMI E5）

### 2.1 On-Wire 编码结构

```
┌─────────────────────────────────────────────────────────────────────┐
│                    SECS-II Item 编码格式                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  每个 Item 的编码形态：                                              │
│  ┌────────────────┬────────────────────┬──────────────────────┐    │
│  │  Format Byte   │   Length Field     │      Payload         │    │
│  │     (1B)       │    (1~3 Bytes)     │    (0~16MB)          │    │
│  └────────────────┴────────────────────┴──────────────────────┘    │
│                                                                     │
│  Format Byte 结构（8 bits）：                                        │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  bit 7-2: format_code (6 bits)                              │   │
│  │  bit 1-0: length_bytes (2 bits)                             │   │
│  │           00 = 无效                                          │   │
│  │           01 = 1 byte length                                │   │
│  │           10 = 2 byte length                                │   │
│  │           11 = 3 byte length                                │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  Format Byte 计算公式：                                              │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  format_byte = (format_code << 2) | length_bytes            │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.2 Format Code 映射表

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Format Code 定义（types.hpp）                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  format_code     值      说明              Length 语义              │
│  ─────────────────────────────────────────────────────────────────  │
│  list          0x00     嵌套列表           子元素个数               │
│  binary        0x08     二进制数据         字节数                    │
│  boolean       0x09     布尔数组           元素个数                  │
│  ascii         0x10     ASCII 字符串       字节数                    │
│  i8            0x18     int64 数组         字节数 (n*8)             │
│  i1            0x19     int8 数组          字节数 (n*1)             │
│  i2            0x1A     int16 数组         字节数 (n*2)             │
│  i4            0x1C     int32 数组         字节数 (n*4)             │
│  f8            0x20     double 数组        字节数 (n*8)             │
│  f4            0x24     float 数组         字节数 (n*4)             │
│  u8            0x28     uint64 数组        字节数 (n*8)             │
│  u1            0x29     uint8 数组         字节数 (n*1)             │
│  u2            0x2A     uint16 数组        字节数 (n*2)             │
│  u4            0x2C     uint32 数组        字节数 (n*4)             │
│                                                                     │
│  注意：List 的 Length 表示"子元素个数"，其他类型表示"字节数"        │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 3. Item 数据模型

### 3.1 类型系统设计

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Item 类型系统                                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Item 内部使用 std::variant 承载所有类型：                           │
│                                                                     │
│  using storage_type = std::variant<                                 │
│      List,     // std::vector<Item> - 可嵌套                        │
│      ASCII,    // struct { std::string value; }                     │
│      Binary,   // struct { std::vector<byte> value; }               │
│      Boolean,  // struct { std::vector<bool> values; }              │
│      I1,       // struct { std::vector<int8_t> values; }            │
│      I2,       // struct { std::vector<int16_t> values; }           │
│      I4,       // struct { std::vector<int32_t> values; }           │
│      I8,       // struct { std::vector<int64_t> values; }           │
│      U1,       // struct { std::vector<uint8_t> values; }           │
│      U2,       // struct { std::vector<uint16_t> values; }          │
│      U4,       // struct { std::vector<uint32_t> values; }          │
│      U8,       // struct { std::vector<uint64_t> values; }          │
│      F4,       // struct { std::vector<float> values; }             │
│      F8        // struct { std::vector<double> values; }            │
│  >;                                                                 │
│                                                                     │
│  设计要点：                                                         │
│  ├── 数值类型统一用 vector 承载（单值也是 size=1）                   │
│  ├── ASCII 以 std::string 存储（支持内含 \0）                       │
│  ├── Boolean 使用 std::vector<bool>（位压缩，不保证连续内存）       │
│  └── Item 不可默认构造，必须指定类型                                 │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 3.2 Item 创建方式

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Item 工厂方法                                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  // 静态工厂方法                                                    │
│  Item::list({child1, child2, ...})   // 创建 List                   │
│  Item::ascii("hello")                // 创建 ASCII                  │
│  Item::binary({0x01, 0x02})          // 创建 Binary                 │
│  Item::boolean({true, false})        // 创建 Boolean                │
│  Item::i1({-1, 0, 127})              // 创建 I1                     │
│  Item::i2({-32768, 32767})           // 创建 I2                     │
│  Item::i4({...})                     // 创建 I4                     │
│  Item::i8({...})                     // 创建 I8                     │
│  Item::u1({0, 255})                  // 创建 U1                     │
│  Item::u2({0, 65535})                // 创建 U2                     │
│  Item::u4({...})                     // 创建 U4                     │
│  Item::u8({...})                     // 创建 U8                     │
│  Item::f4({1.0f, 2.0f})              // 创建 F4                     │
│  Item::f8({1.0, 2.0})                // 创建 F8                     │
│                                                                     │
│  // 访问器                                                          │
│  item.get_if<List>()     // 获取 List 指针，类型不匹配返回 nullptr  │
│  item.is_list()          // 判断是否为 List                         │
│  item.storage()          // 获取底层 variant 引用                   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 3.3 嵌套 List 示例

```
┌─────────────────────────────────────────────────────────────────────┐
│                    嵌套 List 结构示例                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  消息体：S1F14（通信建立响应）                                       │
│  ┌───────────────────────────────────────────────────────────────┐ │
│  │  <L                                                           │ │
│  │    <U2 1>                    // COMMACK                       │ │
│  │    <L                        // MDLN/SOFTREV                  │ │
│  │      <A "EQUIP_MODEL">       // MDLN                          │ │
│  │      <A "1.0.0">             // SOFTREV                       │ │
│  │    >                                                          │ │
│  │  >                                                            │ │
│  └───────────────────────────────────────────────────────────────┘ │
│                                                                     │
│  代码构造：                                                         │
│  ┌───────────────────────────────────────────────────────────────┐ │
│  │  auto msg = Item::list({                                      │ │
│  │      Item::u2({1}),                     // COMMACK            │ │
│  │      Item::list({                       // 嵌套 List          │ │
│  │          Item::ascii("EQUIP_MODEL"),    // MDLN               │ │
│  │          Item::ascii("1.0.0")           // SOFTREV            │ │
│  │      })                                                       │ │
│  │  });                                                          │ │
│  └───────────────────────────────────────────────────────────────┘ │
│                                                                     │
│  树形结构：                                                         │
│             List (root)                                             │
│            /          \                                             │
│        U2[1]       List                                             │
│                   /      \                                          │
│              ASCII      ASCII                                       │
│           "EQUIP_MODEL" "1.0.0"                                     │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 4. 编码实现

### 4.1 编码流程

```
┌─────────────────────────────────────────────────────────────────────┐
│                    encode(item, out) 流程                           │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. encoded_size(item) - 计算编码后总长度                           │
│     │                                                               │
│     └──> 递归遍历 Item 树：                                         │
│          ┌──────────────────────────────────────────────────────┐  │
│          │  size = 1 (format_byte)                              │  │
│          │       + length_bytes_for(length)                     │  │
│          │       + payload_size                                 │  │
│          │                                                      │  │
│          │  对于 List: payload_size = Σ encoded_size(child)     │  │
│          │  对于其他: payload_size = data.size() * elem_size    │  │
│          └──────────────────────────────────────────────────────┘  │
│                                                                     │
│  2. out.resize(offset + size) - 一次性扩容                          │
│                                                                     │
│  3. encode_to(span, item, written) - 写入数据                       │
│     │                                                               │
│     └──> 使用 SpanWriter 辅助类：                                   │
│          ┌──────────────────────────────────────────────────────┐  │
│          │  a. write_u8(format_byte)                            │  │
│          │  b. write_be_u32(length, length_bytes)               │  │
│          │  c. encode_payload(item):                            │  │
│          │     - List: 递归 encode_item(child)                  │  │
│          │     - ASCII/Binary: write_bytes(data)                │  │
│          │     - Boolean: 逐个写入 0x00/0x01                    │  │
│          │     - 数值类型: 大端序写入                           │  │
│          └──────────────────────────────────────────────────────┘  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 4.2 Length 字段变长编码

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Length 字段编码规则                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Length 范围              字节数    Format Byte 低 2 位             │
│  ────────────────────────────────────────────────────────────────  │
│  0 ~ 255                  1 byte    01 (binary)                    │
│  256 ~ 65535              2 bytes   10 (binary)                    │
│  65536 ~ 16777215         3 bytes   11 (binary)                    │
│                                                                     │
│  编码示例：                                                         │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  length = 100:                                              │    │
│  │    length_bytes = 1, format_byte[1:0] = 01                  │    │
│  │    output: [0x64]                                           │    │
│  │                                                             │    │
│  │  length = 1000:                                             │    │
│  │    length_bytes = 2, format_byte[1:0] = 10                  │    │
│  │    output: [0x03, 0xE8]  (big-endian)                       │    │
│  │                                                             │    │
│  │  length = 100000:                                           │    │
│  │    length_bytes = 3, format_byte[1:0] = 11                  │    │
│  │    output: [0x01, 0x86, 0xA0]  (big-endian)                 │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  最大长度：kMaxLength = 0x00FFFFFF (16,777,215 bytes)              │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 4.3 数值类型大端序编码

```
┌─────────────────────────────────────────────────────────────────────┐
│                    大端序编码（Big-Endian）                          │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  SECS-II 规定所有多字节数值按大端序传输：                            │
│                                                                     │
│  示例：U4 值 0x12345678 的编码                                      │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  内存布局（小端机器）: 78 56 34 12                          │    │
│  │  on-wire 编码:        12 34 56 78  (高字节在前)             │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  实现代码（SpanWriter::write_be_uint）：                            │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  for (i = 0; i < sizeof(UInt); ++i) {                       │    │
│  │      shift = 8 * (sizeof(UInt) - 1 - i);                    │    │
│  │      write_u8((v >> shift) & 0xFF);                         │    │
│  │  }                                                          │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  有符号整数处理：                                                   │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  I4 值 -1 (0xFFFFFFFF 补码)                                 │    │
│  │  转换: static_cast<uint32_t>(-1) = 0xFFFFFFFF               │    │
│  │  编码: FF FF FF FF (保留补码位模式)                         │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  浮点数处理：                                                       │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  F4 值 1.0f                                                 │    │
│  │  std::bit_cast<uint32_t>(1.0f) = 0x3F800000                 │    │
│  │  编码: 3F 80 00 00 (IEEE 754 格式)                          │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 5. 解码实现

### 5.1 解码流程

```
┌─────────────────────────────────────────────────────────────────────┐
│                    decode_one(in, out, consumed) 流程               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  使用 SpanReader 辅助类从输入流中读取：                              │
│                                                                     │
│  1. read_u8(format_byte)                                            │
│     │                                                               │
│     ├── length_bytes = format_byte & 0x03                           │
│     │   └── 必须是 1/2/3，否则返回 invalid_header                   │
│     │                                                               │
│     └── fmt_bits = format_byte >> 2                                 │
│         └── 通过 format_code_from_bits() 验证                       │
│                                                                     │
│  2. read_be_u32(length_bytes, length)                               │
│     │                                                               │
│     └── 检查: length <= kMaxLength                                  │
│                                                                     │
│  3. 根据 format_code 分支处理：                                     │
│     │                                                               │
│     ├── List:                                                       │
│     │   ┌────────────────────────────────────────────────────────┐ │
│     │   │  for (i = 0; i < length; ++i) {                        │ │
│     │   │      decode_item(r, child, depth+1, budget, limits);   │ │
│     │   │      items.push_back(child);                           │ │
│     │   │  }                                                     │ │
│     │   │  out = Item(List{items});                              │ │
│     │   └────────────────────────────────────────────────────────┘ │
│     │                                                               │
│     ├── ASCII:                                                      │
│     │   ┌────────────────────────────────────────────────────────┐ │
│     │   │  read_payload(length, payload);                        │ │
│     │   │  out = Item(ASCII{string(payload)});                   │ │
│     │   └────────────────────────────────────────────────────────┘ │
│     │                                                               │
│     └── 数值类型:                                                   │
│         ┌────────────────────────────────────────────────────────┐ │
│         │  read_payload(length, payload);                        │ │
│         │  验证: length % sizeof(T) == 0                         │ │
│         │  for (i = 0; i < count; ++i) {                         │ │
│         │      v[i] = read_be_uint<T>(payload, i*sizeof(T));     │ │
│         │  }                                                     │ │
│         │  out = Item(T{v});                                     │ │
│         └────────────────────────────────────────────────────────┘ │
│                                                                     │
│  4. consumed = reader.consumed()                                    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 5.2 资源限制（DecodeLimits）

```
┌─────────────────────────────────────────────────────────────────────┐
│                    DecodeLimits 防护机制                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  解码来自网络的不可信数据时，需要防止资源耗尽攻击：                  │
│                                                                     │
│  struct DecodeLimits {                                              │
│      size_t max_depth{64};            // 最大嵌套深度               │
│      uint32_t max_list_items{65535};  // 单个 List 最大子元素数     │
│      uint32_t max_payload_bytes{4MB}; // 单个 Item 最大 payload     │
│      size_t max_total_items{1M};      // 整棵树最大节点数           │
│      size_t max_total_bytes{64MB};    // 整棵树最大 payload 总量    │
│  };                                                                 │
│                                                                     │
│  检查点：                                                           │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  1. 递归深度检查:                                           │    │
│  │     if (depth > limits.max_depth) -> invalid_header         │    │
│  │                                                             │    │
│  │  2. 节点数预算:                                              │    │
│  │     if (budget.total_items >= limits.max_total_items)       │    │
│  │        -> total_budget_exceeded                             │    │
│  │                                                             │    │
│  │  3. List 子元素数:                                          │    │
│  │     if (length > limits.max_list_items)                     │    │
│  │        -> list_too_large                                    │    │
│  │                                                             │    │
│  │  4. 单项 payload 大小:                                      │    │
│  │     if (length > limits.max_payload_bytes)                  │    │
│  │        -> payload_too_large                                 │    │
│  │                                                             │    │
│  │  5. 总 payload 字节数:                                      │    │
│  │     if (budget.total_bytes + length > limits.max_total_bytes)│   │
│  │        -> total_budget_exceeded                             │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  攻击场景示例：                                                     │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  深度炸弹: <L <L <L <L ... >>> (65层嵌套)                   │    │
│  │  -> depth > 64, 返回 invalid_header                         │    │
│  │                                                             │    │
│  │  List 炸弹: <L 100000 元素>                                 │    │
│  │  -> length > 65535, 返回 list_too_large                     │    │
│  │                                                             │    │
│  │  Payload 炸弹: <Binary 100MB>                               │    │
│  │  -> length > 4MB, 返回 payload_too_large                    │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 6. 错误码系统

```
┌─────────────────────────────────────────────────────────────────────┐
│                    secs::ii::errc 错误码                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  enum class errc : int {                                            │
│      ok = 0,                 // 成功                                │
│      truncated = 1,          // 输入不完整                          │
│      invalid_header = 2,     // 无效头部（format_byte/length_bytes）│
│      invalid_format = 3,     // 无效 format_code                    │
│      length_overflow = 4,    // 长度字段超出限制                    │
│      length_mismatch = 5,    // 长度与数据不匹配（如 I4 非 4 倍数） │
│      buffer_overflow = 6,    // 输出缓冲区不足                      │
│      list_too_large = 7,     // List 子元素数超限                   │
│      payload_too_large = 8,  // 单项 payload 超限                   │
│      total_budget_exceeded = 9, // 总预算超限                       │
│      out_of_memory = 10,     // 内存分配失败                        │
│  };                                                                 │
│                                                                     │
│  错误分类 (category name = "secs.ii"):                              │
│  ├── 输入错误: truncated, invalid_header, invalid_format,           │
│  │            length_overflow, length_mismatch                      │
│  ├── 输出错误: buffer_overflow                                      │
│  ├── 资源限制: list_too_large, payload_too_large,                   │
│  │            total_budget_exceeded                                 │
│  └── 系统错误: out_of_memory                                        │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 7. 完整编码示例

```
┌─────────────────────────────────────────────────────────────────────┐
│                    编码示例：S2F34 响应                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  消息结构：                                                         │
│  <L                                                                 │
│    <U1 0>         // DRACK (0=OK)                                   │
│  >                                                                  │
│                                                                     │
│  编码过程：                                                         │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  1. 根 List:                                                │    │
│  │     format_code = 0x00, length = 1 (子元素个数)             │    │
│  │     length_bytes = 1 (因为 1 <= 255)                        │    │
│  │     format_byte = (0x00 << 2) | 1 = 0x01                    │    │
│  │     输出: [0x01, 0x01]  <- List header                      │    │
│  │                                                             │    │
│  │  2. U1 子元素:                                              │    │
│  │     format_code = 0x29, length = 1 (1 byte payload)         │    │
│  │     length_bytes = 1                                        │    │
│  │     format_byte = (0x29 << 2) | 1 = 0xA5                    │    │
│  │     输出: [0xA5, 0x01, 0x00]  <- U1 item                    │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  最终字节序列: [0x01, 0x01, 0xA5, 0x01, 0x00]                       │
│                                                                     │
│  解析：                                                             │
│  ┌─────┬─────┬─────┬─────┬─────┐                                   │
│  │ 01  │ 01  │ A5  │ 01  │ 00  │                                   │
│  └──┬──┴──┬──┴──┬──┴──┬──┴──┬──┘                                   │
│     │     │     │     │     │                                       │
│     │     │     │     │     └── U1 value = 0                        │
│     │     │     │     └── U1 length = 1                             │
│     │     │     └── U1 format_byte (0x29<<2|1)                      │
│     │     └── List length = 1                                       │
│     └── List format_byte (0x00<<2|1)                                │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 8. Item 比较语义

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Item 相等性比较                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  特殊处理：浮点数采用"按位相等"而非"数值相等"                       │
│                                                                     │
│  原因：                                                             │
│  1. SECS-II 编解码以字节为单位，关注的是位模式是否一致              │
│  2. 正确处理 NaN、-0/+0 等边界情况                                  │
│                                                                     │
│  实现代码（item.cpp）：                                             │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  bool float_bits_equal(float a, float b) {                  │    │
│  │      return bit_cast<uint32_t>(a) == bit_cast<uint32_t>(b); │    │
│  │  }                                                          │    │
│  │                                                             │    │
│  │  bool double_bits_equal(double a, double b) {               │    │
│  │      return bit_cast<uint64_t>(a) == bit_cast<uint64_t>(b); │    │
│  │  }                                                          │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  比较示例：                                                         │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  F4{0.0f} == F4{-0.0f}   // false (位模式不同)              │    │
│  │  F4{NaN}  == F4{NaN}     // true  (相同位模式)              │    │
│  │  F4{1.0f} == F4{1.0f}    // true                            │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 9. 源文件清单

| 文件 | 行数 | 说明 |
|------|------|------|
| `include/secs/ii/types.hpp` | ~44 | format_code 枚举定义 |
| `include/secs/ii/item.hpp` | ~175 | Item 类型系统 |
| `include/secs/ii/codec.hpp` | ~104 | 编解码 API |
| `src/ii/item.cpp` | ~152 | Item 实现（工厂方法、比较） |
| `src/ii/codec.cpp` | ~1015 | 编解码核心实现 |
