# SECS-I 模块详细实现原理

> 文档生成日期：2026-01-06
> 基于源码版本：当前 main 分支
> 对应标准：SEMI E4（SECS-I Message Transfer）

## 1. 模块概述

`secs::secs1` 模块实现 SECS-I 串口半双工传输层，提供：

- **Block 帧**：`Header` / `encode_block()` / `decode_block()`
- **分包重组**：`fragment_message()` / `Reassembler`
- **状态机**：`StateMachine`（ENQ/EOT/ACK/NAK 握手 + 超时）
- **链路抽象**：`Link` 接口

```
┌─────────────────────────────────────────────────────────────────────┐
│                        secs::secs1 模块                             │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                   StateMachine（状态机）                     │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │   │
│  │  │ ENQ/EOT握手 │  │ Block收发   │  │ T1/T2/T3/T4 超时    │  │   │
│  │  │ 半双工控制  │  │ ACK/NAK确认 │  │ 重试机制            │  │   │
│  │  └─────────────┘  └─────────────┘  └─────────────────────┘  │   │
│  └───────────────────────────▲─────────────────────────────────┘   │
│                              │                                      │
│  ┌───────────────────────────┴─────────────────────────────────┐   │
│  │                    Block（数据块层）                         │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │   │
│  │  │ Header(10B) │  │ Data(0-244B)│  │ Checksum(2B)        │  │   │
│  │  │ encode/decode│ │ 分包/重组   │  │                     │  │   │
│  │  └─────────────┘  └─────────────┘  └─────────────────────┘  │   │
│  └───────────────────────────▲─────────────────────────────────┘   │
│                              │                                      │
│  ┌───────────────────────────┴─────────────────────────────────┐   │
│  │                    Link（链路抽象）                          │   │
│  │  async_read_byte() / async_write() / cancel() / close()     │   │
│  │  实现：MemoryLink（测试）、PosixSerialLink（串口）           │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 2. SECS-I 协议字节（SEMI E4）

### 2.1 控制字节定义

```
┌─────────────────────────────────────────────────────────────────────┐
│                    SECS-I 控制字节                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  字节    值      名称      用途                                     │
│  ─────────────────────────────────────────────────────────────────  │
│  ENQ    0x05    Enquiry   请求发送权（"我要发数据了"）              │
│  EOT    0x04    End of    授予发送权（"你可以发了"）                │
│                 Transmission                                        │
│  ACK    0x06    Acknowledge 确认收到且校验通过                      │
│  NAK    0x15    Negative   否认（校验失败/拒绝）                     │
│                 Acknowledge                                         │
│                                                                     │
│  半双工握手时序：                                                   │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  Sender                          Receiver                   │    │
│  │    │                                │                       │    │
│  │    │──── ENQ ──────────────────────>│  请求发送权           │    │
│  │    │                                │                       │    │
│  │    │<─── EOT ───────────────────────│  授予发送权           │    │
│  │    │                                │                       │    │
│  │    │──── Block Frame ──────────────>│  发送数据块           │    │
│  │    │                                │                       │    │
│  │    │<─── ACK ───────────────────────│  确认接收成功         │    │
│  │    │                                │                       │    │
│  │  或者：                                                     │    │
│  │    │<─── NAK ───────────────────────│  接收失败，请重发     │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.2 定时器定义

```
┌─────────────────────────────────────────────────────────────────────┐
│                    SECS-I 定时器（Timeouts）                        │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  定时器   默认值    用途                                            │
│  ─────────────────────────────────────────────────────────────────  │
│  T1       500ms    字符间隔超时（Block 内部字节间隔）               │
│  T2       10s      协议超时（ENQ->EOT / Block->ACK）               │
│  T3       45s      回复超时（消息级别，等待对方响应消息）           │
│  T4       45s      Block 间超时（多 Block 消息内部）               │
│                                                                     │
│  时序示意：                                                         │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │                                                             │    │
│  │  ENQ ─────────────────────────────────────────> EOT        │    │
│  │       <────────────── T2 ─────────────────────>            │    │
│  │                                                             │    │
│  │  Block 内部：                                               │    │
│  │  ┌─B1─┐ ┌─B2─┐ ┌─B3─┐ ... ┌─Bn─┐                          │    │
│  │       <T1>  <T1>                                            │    │
│  │                                                             │    │
│  │  Block 发送后等待确认：                                     │    │
│  │  Block ────────────────────────────────────────> ACK/NAK   │    │
│  │        <────────────── T2 ─────────────────────>           │    │
│  │                                                             │    │
│  │  多 Block 消息：                                            │    │
│  │  Block1 ──> ACK ──> Block2 ──> ACK ──> ... ──> BlockN      │    │
│  │                 <T4>       <T4>                              │    │
│  │                                                             │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 3. Block 帧格式

### 3.1 帧结构

```
┌─────────────────────────────────────────────────────────────────────┐
│                    SECS-I Block 帧格式                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────┬──────────────────────────────┬──────────────────────┐ │
│  │ Length  │          Payload             │      Checksum        │ │
│  │  (1B)   │    Header(10B) + Data(N)     │        (2B)          │ │
│  └─────────┴──────────────────────────────┴──────────────────────┘ │
│                                                                     │
│  约束：                                                             │
│  ├── Length = Header(10) + Data(0~244) = 10 ~ 254                   │
│  ├── kHeaderSize = 10                                               │
│  ├── kMaxBlockDataSize = 244                                        │
│  ├── kMaxBlockLength = 254                                          │
│  └── kMaxBlockFrameSize = 1 + 254 + 2 = 257                         │
│                                                                     │
│  Checksum 计算：                                                    │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  对 Payload（Length 个字节）求和，取低 16 位               │    │
│  │  uint16_t checksum(bytes) {                                 │    │
│  │      uint32_t sum = 0;                                      │    │
│  │      for (byte b : bytes) sum += b;                         │    │
│  │      return sum & 0xFFFF;                                   │    │
│  │  }                                                          │    │
│  │  写入时按大端序（高字节在前）                               │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 3.2 Header 结构（10 字节）

```
┌─────────────────────────────────────────────────────────────────────┐
│                    SECS-I Block Header 布局                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  字节级布局（兼容 c_dump 实现）：                                   │
│  ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐    │
│  │  0  │  1  │  2  │  3  │  4  │  5  │  6  │  7  │  8  │  9  │    │
│  └──┬──┴──┬──┴──┬──┴──┬──┴──┬──┴──┬──┴──┬──┴──┬──┴──┬──┴──┬──┘    │
│     │     │     │     │     │     │     │     │     │     │        │
│     │     │     │     │     │     └─────┴─────┴─────┴─────┘        │
│     │     │     │     │     │           SystemBytes (4B BE)        │
│     │     │     │     │     │                                      │
│     │     │     │     └─────┴── E(1) + BlockNumber[14:8](7)        │
│     │     │     │                  + BlockNumber[7:0](8)           │
│     │     │     │                                                  │
│     │     │     └── Function (8 bits)                              │
│     │     │                                                        │
│     │     └── W(1) + Stream(7)                                     │
│     │                                                              │
│     └──────── R(1) + DeviceID[14:8](7) + DeviceID[7:0](8)         │
│                                                                     │
│  位域详解：                                                         │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  Byte 0: [R-bit(1)] [DeviceID 高 7 位]                      │    │
│  │  Byte 1: [DeviceID 低 8 位]                                 │    │
│  │          DeviceID = 15 位有效 (0~32767)                     │    │
│  │          R-bit = 方向位 (0=Host->Equip, 1=Equip->Host)      │    │
│  │                                                             │    │
│  │  Byte 2: [W-bit(1)] [Stream 7 位]                           │    │
│  │          W-bit = 等待位 (1=需要回应)                        │    │
│  │                                                             │    │
│  │  Byte 3: [Function 8 位]                                    │    │
│  │                                                             │    │
│  │  Byte 4: [E-bit(1)] [BlockNumber 高 7 位]                   │    │
│  │  Byte 5: [BlockNumber 低 8 位]                              │    │
│  │          E-bit = 结束位 (1=最后一个块)                      │    │
│  │          BlockNumber = 15 位有效 (1~32767)                  │    │
│  │                                                             │    │
│  │  Byte 6-9: [SystemBytes 32 位，大端序]                      │    │
│  │            事务标识                                         │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 3.3 编解码实现

```
┌─────────────────────────────────────────────────────────────────────┐
│                    encode_block(header, data, out) 流程             │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. 校验 data.size() <= kMaxBlockDataSize (244)                     │
│                                                                     │
│  2. 计算 length = kHeaderSize + data.size()                         │
│                                                                     │
│  3. 构造 payload (Header + Data)：                                  │
│     ┌────────────────────────────────────────────────────────────┐ │
│     │  // Byte 0-1: R-bit + DeviceID                             │ │
│     │  byte0 = (reverse_bit << 7) | ((device_id >> 8) & 0x7F)    │ │
│     │  byte1 = device_id & 0xFF                                  │ │
│     │                                                            │ │
│     │  // Byte 2-3: W-bit + Stream + Function                    │ │
│     │  byte2 = (wait_bit << 7) | (stream & 0x7F)                 │ │
│     │  byte3 = function                                          │ │
│     │                                                            │ │
│     │  // Byte 4-5: E-bit + BlockNumber                          │ │
│     │  byte4 = (end_bit << 7) | ((block_number >> 8) & 0x7F)     │ │
│     │  byte5 = block_number & 0xFF                               │ │
│     │                                                            │ │
│     │  // Byte 6-9: SystemBytes (big-endian)                     │ │
│     │  byte6 = (system_bytes >> 24) & 0xFF                       │ │
│     │  byte7 = (system_bytes >> 16) & 0xFF                       │ │
│     │  byte8 = (system_bytes >> 8) & 0xFF                        │ │
│     │  byte9 = system_bytes & 0xFF                               │ │
│     │                                                            │ │
│     │  // 追加 Data                                              │ │
│     │  append(data)                                              │ │
│     └────────────────────────────────────────────────────────────┘ │
│                                                                     │
│  4. 计算 checksum = checksum(payload)                               │
│                                                                     │
│  5. 输出 frame：                                                    │
│     ┌────────┬─────────────────────────┬──────────────────┐        │
│     │ length │        payload          │ checksum (BE)    │        │
│     │  (1B)  │ (Header 10B + Data NB)  │     (2B)         │        │
│     └────────┴─────────────────────────┴──────────────────┘        │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

```
┌─────────────────────────────────────────────────────────────────────┐
│                    decode_block(frame, out) 流程                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. 读取 length = frame[0]                                          │
│     ├── 校验 length >= kHeaderSize (10)                             │
│     └── 校验 length <= kMaxBlockLength (254)                        │
│                                                                     │
│  2. 校验帧长度：frame.size() >= 1 + length + 2                      │
│                                                                     │
│  3. 提取 payload = frame[1:1+length]                                │
│                                                                     │
│  4. 校验 checksum：                                                 │
│     ┌────────────────────────────────────────────────────────────┐ │
│     │  expected = read_u16_be(frame[1+length:1+length+2])        │ │
│     │  actual = checksum(payload)                                │ │
│     │  if (expected != actual) return checksum_mismatch;         │ │
│     └────────────────────────────────────────────────────────────┘ │
│                                                                     │
│  5. 解析 Header：                                                   │
│     ┌────────────────────────────────────────────────────────────┐ │
│     │  reverse_bit  = (payload[0] >> 7) & 0x01                   │ │
│     │  device_id    = ((payload[0] & 0x7F) << 8) | payload[1]    │ │
│     │  wait_bit     = (payload[2] >> 7) & 0x01                   │ │
│     │  stream       = payload[2] & 0x7F                          │ │
│     │  function     = payload[3]                                 │ │
│     │  end_bit      = (payload[4] >> 7) & 0x01                   │ │
│     │  block_number = ((payload[4] & 0x7F) << 8) | payload[5]    │ │
│     │  system_bytes = read_u32_be(payload[6:10])                 │ │
│     └────────────────────────────────────────────────────────────┘ │
│                                                                     │
│  6. 提取 data = payload[10:]                                        │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 4. 消息分包与重组

### 4.1 分包（fragment_message）

```
┌─────────────────────────────────────────────────────────────────────┐
│                    消息分包机制                                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  SECS-I 每个 Block 最多携带 244 字节数据，大消息需要分包：          │
│                                                                     │
│  fragment_message(base_header, payload) 流程：                      │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  vector<vector<byte>> blocks;                               │    │
│  │  size_t offset = 0;                                         │    │
│  │  uint16_t block_number = 1;                                 │    │
│  │                                                             │    │
│  │  while (offset < payload.size()) {                          │    │
│  │      size_t chunk_size = min(244, payload.size() - offset); │    │
│  │      bool is_last = (offset + chunk_size >= payload.size());│    │
│  │                                                             │    │
│  │      Header h = base_header;                                │    │
│  │      h.block_number = block_number++;                       │    │
│  │      h.end_bit = is_last;                                   │    │
│  │                                                             │    │
│  │      vector<byte> frame;                                    │    │
│  │      encode_block(h, payload[offset:offset+chunk_size], frame);│  │
│  │      blocks.push_back(frame);                               │    │
│  │                                                             │    │
│  │      offset += chunk_size;                                  │    │
│  │  }                                                          │    │
│  │                                                             │    │
│  │  return blocks;                                             │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  示例：500 字节消息的分包                                           │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  原始消息：[───────────── 500 bytes ──────────────────]    │    │
│  │                                                             │    │
│  │  分包结果：                                                 │    │
│  │  Block 1: [Header(E=0,BN=1)] [Data: 244 bytes] [Checksum]   │    │
│  │  Block 2: [Header(E=0,BN=2)] [Data: 244 bytes] [Checksum]   │    │
│  │  Block 3: [Header(E=1,BN=3)] [Data: 12 bytes]  [Checksum]   │    │
│  │                    ^                                        │    │
│  │                    E=1 表示最后一个块                       │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 4.2 重组（Reassembler）

```
┌─────────────────────────────────────────────────────────────────────┐
│                    消息重组机制                                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Reassembler 类负责将多个 Block 重组为完整消息：                    │
│                                                                     │
│  状态：                                                             │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  optional<uint16_t> expected_device_id_; // 可选 DeviceID 校验│  │
│  │  bool has_header_{false};                // 是否已收到首块   │    │
│  │  Header header_{};                       // 消息头信息       │    │
│  │  uint16_t next_block_{1};                // 期望的下一个块号 │    │
│  │  vector<byte> body_{};                   // 累积的消息体     │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  accept(block) 流程：                                               │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  1. DeviceID 校验（如果配置了）：                           │    │
│  │     if (expected_device_id_ && block.device_id != *expected_)│   │
│  │         return device_id_mismatch;                          │    │
│  │                                                             │    │
│  │  2. BlockNumber 序列校验：                                  │    │
│  │     if (block.block_number != next_block_)                  │    │
│  │         return block_sequence_error;                        │    │
│  │                                                             │    │
│  │  3. 首块处理：                                              │    │
│  │     if (!has_header_) {                                     │    │
│  │         header_ = block.header;  // 保存消息级头信息        │    │
│  │         has_header_ = true;                                 │    │
│  │     }                                                       │    │
│  │                                                             │    │
│  │  4. 累积数据：                                              │    │
│  │     body_.append(block.data);                               │    │
│  │                                                             │    │
│  │  5. 更新状态：                                              │    │
│  │     ++next_block_;                                          │    │
│  │                                                             │    │
│  │  6. 检查完成：                                              │    │
│  │     // has_message() = has_header_ && header_.end_bit       │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  重组时序：                                                         │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  Block(BN=1,E=0) ──> accept() ──> has_message()=false       │    │
│  │  Block(BN=2,E=0) ──> accept() ──> has_message()=false       │    │
│  │  Block(BN=3,E=1) ──> accept() ──> has_message()=true        │    │
│  │                                                             │    │
│  │  message_header() -> 首块的 Header                          │    │
│  │  message_body()   -> 累积的完整数据                         │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 5. Link 链路抽象

### 5.1 接口定义

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Link 抽象接口                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  class Link {                                                       │
│  public:                                                            │
│      virtual ~Link() = default;                                     │
│                                                                     │
│      // 获取执行器                                                  │
│      virtual any_io_executor executor() const = 0;                  │
│                                                                     │
│      // 读取单个字节（带超时）                                      │
│      virtual awaitable<pair<error_code, byte>>                      │
│          async_read_byte(optional<duration> timeout) = 0;           │
│                                                                     │
│      // 写入数据                                                    │
│      virtual awaitable<error_code>                                  │
│          async_write(bytes_view data) = 0;                          │
│                                                                     │
│      // 取消正在进行的操作                                          │
│      virtual void cancel() noexcept = 0;                            │
│                                                                     │
│      // 关闭链路                                                    │
│      virtual void close() noexcept = 0;                             │
│  };                                                                 │
│                                                                     │
│  为什么逐字节读取？                                                 │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  SECS-I 是半双工协议，需要识别控制字节（ENQ/EOT/ACK/NAK）   │    │
│  │  逐字节读取便于状态机处理：                                 │    │
│  │  - 收到 ENQ: 对方请求发送                                   │    │
│  │  - 收到 EOT: 对方授予发送权                                 │    │
│  │  - 收到 ACK/NAK: 确认/否认                                  │    │
│  │  - 其他字节: Block 数据                                     │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 5.2 实现类

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Link 实现类                                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. MemoryLink（内存链路 - 用于单元测试）                           │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  class MemoryLink : public Link {                           │    │
│  │      deque<byte> buffer_;  // 内存队列                      │    │
│  │      Event data_ready_;    // 数据可读事件                  │    │
│  │  };                                                         │    │
│  │                                                             │    │
│  │  // 创建一对互联的内存链路                                  │    │
│  │  auto [a, b] = MemoryLink::create_pair(executor);           │    │
│  │  // a 写入的数据可以从 b 读取，反之亦然                     │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  2. PosixSerialLink（POSIX 串口 - 用于真实设备）                    │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  class PosixSerialLink : public Link {                      │    │
│  │      asio::posix::stream_descriptor serial_;                │    │
│  │      struct termios original_termios_;                      │    │
│  │  };                                                         │    │
│  │                                                             │    │
│  │  // 打开串口                                                │    │
│  │  auto link = PosixSerialLink::open(                         │    │
│  │      executor,                                              │    │
│  │      "/dev/ttyUSB0",  // 串口路径                           │    │
│  │      9600             // 波特率                             │    │
│  │  );                                                         │    │
│  │                                                             │    │
│  │  配置参数（固定）：                                         │    │
│  │  - 8 数据位                                                 │    │
│  │  - 1 停止位                                                 │    │
│  │  - 无奇偶校验                                               │    │
│  │  - 无流控                                                   │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 6. StateMachine 状态机

### 6.1 状态定义

```
┌─────────────────────────────────────────────────────────────────────┐
│                    StateMachine 状态                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  enum class State : uint8_t {                                       │
│      idle = 0,       // 空闲，可以发起收发                          │
│      wait_eot = 1,   // 等待 EOT（已发送 ENQ）                      │
│      wait_block = 2, // 等待 Block 数据                             │
│      wait_check = 3, // 等待 ACK/NAK（已发送 Block）               │
│  };                                                                 │
│                                                                     │
│  状态转换图：                                                       │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │                                                             │    │
│  │            发送 ENQ                                         │    │
│  │       ┌────────────────────┐                                │    │
│  │       │                    ▼                                │    │
│  │  ┌────┴────┐         ┌──────────┐                          │    │
│  │  │  idle   │         │ wait_eot │                          │    │
│  │  └────┬────┘         └────┬─────┘                          │    │
│  │       │                   │                                 │    │
│  │       │ 收到 ENQ          │ 收到 EOT                        │    │
│  │       │ 发送 EOT          │ 发送 Block                      │    │
│  │       ▼                   ▼                                 │    │
│  │  ┌──────────┐       ┌───────────┐                          │    │
│  │  │wait_block│       │wait_check │                          │    │
│  │  └────┬─────┘       └─────┬─────┘                          │    │
│  │       │                   │                                 │    │
│  │       │ 收到完整 Block    │ 收到 ACK                        │    │
│  │       │ 发送 ACK/NAK      │                                 │    │
│  │       │                   │                                 │    │
│  │       └───────────────────┴──────────> idle                 │    │
│  │                                                             │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  并发安全说明：                                                     │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  SECS-I 是半双工协议，同一时刻只能有一个方向的通信。        │    │
│  │  当 state() != idle 时，再次调用 async_send/receive/transact│    │
│  │  会返回 invalid_argument，避免并发读写导致协议错误。        │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 6.2 发送流程（async_send）

```
┌─────────────────────────────────────────────────────────────────────┐
│                    async_send(header, body) 流程                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. 状态检查：                                                      │
│     if (state_ != idle) return invalid_argument;                    │
│                                                                     │
│  2. 分包：                                                          │
│     auto blocks = fragment_message(header, body);                   │
│                                                                     │
│  3. 逐块发送（带重试）：                                            │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  for (auto& block : blocks) {                               │    │
│  │      for (retry = 0; retry < retry_limit_; ++retry) {       │    │
│  │                                                             │    │
│  │          // 3.1 发送 ENQ                                    │    │
│  │          state_ = wait_eot;                                 │    │
│  │          co_await link_.async_write({ENQ});                 │    │
│  │                                                             │    │
│  │          // 3.2 等待 EOT (T2 超时)                          │    │
│  │          auto [ec, b] = co_await async_read_byte(T2);       │    │
│  │          if (ec || b != EOT) continue;  // 重试             │    │
│  │                                                             │    │
│  │          // 3.3 发送 Block                                  │    │
│  │          state_ = wait_check;                               │    │
│  │          co_await link_.async_write(block);                 │    │
│  │                                                             │    │
│  │          // 3.4 等待 ACK (T2 超时)                          │    │
│  │          auto [ec2, b2] = co_await async_read_byte(T2);     │    │
│  │          if (!ec2 && b2 == ACK) {                           │    │
│  │              break;  // 成功，发送下一块                    │    │
│  │          }                                                  │    │
│  │          // NAK 或超时，重试                                │    │
│  │      }                                                      │    │
│  │      if (retry >= retry_limit_) return too_many_retries;    │    │
│  │  }                                                          │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  4. 完成：                                                          │
│     state_ = idle;                                                  │
│     return ok;                                                      │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 6.3 接收流程（async_receive）

```
┌─────────────────────────────────────────────────────────────────────┐
│                    async_receive(timeout) 流程                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. 状态检查：                                                      │
│     if (state_ != idle) return invalid_argument;                    │
│                                                                     │
│  2. 等待 ENQ：                                                      │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  auto [ec, b] = co_await async_read_byte(timeout);          │    │
│  │  if (ec) return {ec, {}};                                   │    │
│  │  if (b != ENQ) return {protocol_error, {}};                 │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  3. 发送 EOT：                                                      │
│     co_await link_.async_write({EOT});                              │
│     state_ = wait_block;                                            │
│                                                                     │
│  4. 接收 Blocks（带重组）：                                         │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  Reassembler reassembler(expected_device_id_);              │    │
│  │                                                             │    │
│  │  while (!reassembler.has_message()) {                       │    │
│  │      // 4.1 读取 Block 帧                                   │    │
│  │      vector<byte> frame;                                    │    │
│  │      frame.push_back(co_await read_byte(T1));  // Length    │    │
│  │      size_t length = frame[0];                              │    │
│  │      for (i = 0; i < length + 2; ++i) {                     │    │
│  │          frame.push_back(co_await read_byte(T1));           │    │
│  │      }                                                      │    │
│  │                                                             │    │
│  │      // 4.2 解码并校验                                      │    │
│  │      DecodedBlock block;                                    │    │
│  │      auto ec = decode_block(frame, block);                  │    │
│  │      if (ec) {                                              │    │
│  │          co_await link_.async_write({NAK});  // 发送 NAK    │    │
│  │          continue;  // 等待重传                             │    │
│  │      }                                                      │    │
│  │                                                             │    │
│  │      // 4.3 重组                                            │    │
│  │      ec = reassembler.accept(block);                        │    │
│  │      if (ec) {                                              │    │
│  │          co_await link_.async_write({NAK});                 │    │
│  │          continue;                                          │    │
│  │      }                                                      │    │
│  │                                                             │    │
│  │      // 4.4 确认                                            │    │
│  │      co_await link_.async_write({ACK});                     │    │
│  │  }                                                          │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  5. 完成：                                                          │
│     state_ = idle;                                                  │
│     return {ok, {reassembler.message_header(),                      │
│                  reassembler.message_body()}};                      │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 6.4 事务流程（async_transact）

```
┌─────────────────────────────────────────────────────────────────────┐
│                    async_transact(header, body) 流程                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  事务 = 发送请求 + 等待响应（适用于 W=1 的 primary 消息）           │
│                                                                     │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  1. 发送请求：                                              │    │
│  │     auto ec = co_await async_send(header, body);            │    │
│  │     if (ec) return {ec, {}};                                │    │
│  │                                                             │    │
│  │  2. 等待响应（T3 超时）：                                   │    │
│  │     return co_await async_receive(T3);                      │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  典型时序：                                                         │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  Host                              Equipment                │    │
│  │    │                                    │                   │    │
│  │    │──── ENQ ─────────────────────────>│                   │    │
│  │    │<─── EOT ──────────────────────────│                   │    │
│  │    │──── S1F1 Block ──────────────────>│                   │    │
│  │    │<─── ACK ──────────────────────────│                   │    │
│  │    │           (async_send 完成)       │                   │    │
│  │    │                                   │ 处理请求...        │    │
│  │    │<─── ENQ ──────────────────────────│                   │    │
│  │    │──── EOT ─────────────────────────>│                   │    │
│  │    │<─── S1F2 Block ───────────────────│                   │    │
│  │    │──── ACK ─────────────────────────>│                   │    │
│  │    │          (async_receive 完成)     │                   │    │
│  │    │                                   │                   │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 7. 错误码系统

```
┌─────────────────────────────────────────────────────────────────────┐
│                    secs::secs1::errc 错误码                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  enum class errc : int {                                            │
│      ok = 0,                  // 成功                               │
│      invalid_block = 1,       // 无效 Block（长度/格式错误）        │
│      checksum_mismatch = 2,   // 校验和不匹配                       │
│      device_id_mismatch = 3,  // DeviceID 不匹配                    │
│      protocol_error = 4,      // 协议错误（非预期字节）             │
│      too_many_retries = 5,    // 重试次数超限                       │
│      block_sequence_error = 6,// Block 序列错误（BlockNumber 不连续）│
│  };                                                                 │
│                                                                     │
│  错误场景示例：                                                     │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  checksum_mismatch:                                         │    │
│  │    收到 Block，计算校验和与帧内校验和不一致                 │    │
│  │    -> 发送 NAK，等待对方重传                                │    │
│  │                                                             │    │
│  │  protocol_error:                                            │    │
│  │    等待 EOT 时收到非 EOT 字节（如 ENQ）                     │    │
│  │    -> 可能是对方也在尝试发送（竞争）                        │    │
│  │                                                             │    │
│  │  too_many_retries:                                          │    │
│  │    连续 3 次（默认）发送 Block 都收到 NAK 或超时            │    │
│  │    -> 通信链路可能有问题                                    │    │
│  │                                                             │    │
│  │  block_sequence_error:                                      │    │
│  │    收到 Block 的 BlockNumber 不是预期值                     │    │
│  │    例如：收到 BN=1 后，下一个应该是 BN=2，但收到 BN=3       │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 8. 源文件清单

| 文件 | 行数 | 说明 |
|------|------|------|
| `include/secs/secs1/block.hpp` | ~133 | Block/Header 定义 |
| `include/secs/secs1/link.hpp` | ~80 | Link 抽象接口 |
| `include/secs/secs1/state_machine.hpp` | ~95 | StateMachine 接口 |
| `include/secs/secs1/timer.hpp` | ~40 | 定时器配置 |
| `include/secs/secs1/posix_serial_link.hpp` | ~200 | POSIX 串口实现 |
| `src/secs1/block.cpp` | ~300 | Block 编解码实现 |
| `src/secs1/link.cpp` | ~150 | MemoryLink 实现 |
| `src/secs1/state_machine.cpp` | ~400 | 状态机实现 |
| `src/secs1/timer.cpp` | ~50 | 定时器实现 |
